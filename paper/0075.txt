NBER WORKING PAPER SERIES

IMPLEMENTING AND DOCUMENTING
RANDOM NUMBER GENERATORS

David C. Hoaglin*

Working Paper No. 75

COMRJTER RESEARCH CEN'ITR FOR ECONOMICS AND MANEL tENT SCIENCE

National Bureau of Economic Research,
575 Technology Square

Inc.

Cambridge, Massachusetts 02139

March 1975

Preliminary: not for quotation

working papers are distributed informally and in limited
numbers for comments only. They should not be quoted without
written permission.
NBER

This report has not undergone the review accorded official NBER

publications; in particular, it has not yet been submitted for
approval by the Board of Directors.

NBER Computer Research Center and Harvard University, Department

of Statistics. Research supported in part by National Science
Foundation Grant GJ-1l54X3 to the National Bureau of Economic'

Research, Inc.

Abstract

As simulation arid Monte Carlo continue to play an iricrasing role in statis-

tical research, careful attention must be given to problems which arise in
implementing and documenting collect ions of random number generators. This

paper examines the value of theoretical as well as empirical evidence in

establishing the quality of generators, the selection of generators to
comçxr'ise a good basic set, the techniques and efficiency of implementation,

and the extent of documentation. Illustrative examples are drawn from vanout current sources.

.
.

Contents

1. Introduction

•

1

2. Uniform Generators

•

1

3. A Basic Library

•

2

4. Implementation

2

5. Documentation

3

6. Sunniry

3

References

3

BIPLUIEWrIN3 AND DOCUMDING
RANDOM NUMBER GENERA'IORS

1. INTRODUCTION

2. UNIFORM GENERATORS

Across the fields of statistics arid coiñputer
science, from theoretical to applied, simulation
and !bnte Carlo continue to play a significant

role. The variety of clever applications is great,
but often it seems that the technical foundations
are shaky. The random-number generators, on which

this whole experimentation structure rests, are
still all too often incautiously selected, haphazarly implemented, and inadequately documented.
Taking examples from arrong the available genera—

tors, algorithms, routines, and libraries, the

balance of this paper examines prevailing practices in selecting, implementing, and documenting
random—number generators and offers some reccinendations.
First, however, we should look further at the
question of prevalence: How widely are simulation
and Tbnte Carlo used in statistical research? In

preparing a position paper on publication of
computation-based results [8] David Andrews and
had occasion to go carefully through the 1973
volumes of Biometrika and Journal of the American

I

Statistical Association, counting pap of vari-

ous kinds. We found that 20% of all papers in—
volved simulation results, and the individual percentages in the three hodies of papers (JASA
Applications, JASA Theory and Methods, and

Biometrika) derted surprisingly little from the

overall figure. Even without comparable data for
the computer science literature, the overall conclusion is clear: simulation is an important component in quite a lot of research.

A source of uniform ranaom numbers is at the heart
of aljrost all algorithms for generating non-

uniform distributions, so it deserves a lot of
attention and is the natural place to start. This

in

observation

view of the
is hardly new, but
available generators it still
example, wherever there is a
computer with a word size of 32
to find the poor generator RANDU [10] -persistence has been rernrkable. Of course, this
generator (along with rrost others in comiron use) is
nultiplicative-corigruentjal, arid all such generators are well-3-iown
produce output sequences
which have regular structure. Specifically, the
set of all n-tuples (Xi,
lattice in Euclidean n-space [13]. For some
high-accuracy multidimensional calculations this
typical

quality of.

needs hasis. For

bits, one is likely
its

to

a

Xi1,..., Xj+nl) fO

type of defect may render all congr'ueritial generators undesirable. Various schemes for permuting,
raridomly sFniffling, or otherwise modifying the output of such basic generators offer reasonable
improvement, but there is still much to be learned.
Returning now to the basic congruential generators,
we should be aware of one important argument in

favor: they are the easiest to analyze
theoretically. As a result we can determine (over
the full period of the generator) several indicative properties of these generators and thus have
a much clearer picture of what we can expect of
them and what we cannot. The lattice structure of
the generators provides the basis for the two rrst
their

widely used theoretical tests: the spectral test

—2—
12] arid the lattice test [2, 14]. Briefly,

at

spectral test in n dimensions looks
(in a
ndardized reciprocal scale) the distance
tween adjacent hyperplanes in the most widely
rated family of hyperplanes in the lattice of

produced by the generator. The lattice
St looks at the length ratio of longest arid
)rtest sides in a reduced basis for the lattice
uples

n-tuples. It is not surprising, then, that
se two tests are rather closely related. Still,

may help our understanding to apply both tests
study the results in dimensions 2 through 6.

it actual test
ith's notation

in

criteria should we use?
[12] for the spectral test we
Lculate C for n2,3,4,5,6 and require that
values be at least 1 . This is the more
ingent of the two criteria Knuth suggested, but

all

se

empirical experience [9] suggests that it
not unreasonably difficult to find multipliers
Lch meet this requirement. For the lattice test
us use I to denote the length ratio of longside to shortest side. Marsaglia suggested
ent

;] requiring L 2, and this seems sensible,
un for n:2,3,4,5,6. (Foniulated in such simple
ns as "Cs > 1" and ??I < 2", the lattice test
iears to be the more stringent of the two). to
Lnts surrunarize this discussion of theoretical
)perties: these theoretical tests are much
:ter for screening congruential generators than
}cuown empirical tests, and no congruential
ierator should be put into use without passing
!Tfl.

3. A BASIC LIBRARY

:'s tum now to what we can do with a carefully
)sen uniform generator. What other generators
)uld we put with it to form a serviceable set
'most simulation purposes? We should not have

h difficulty agreeing on a basic library, and
'easonable list should look raich like this:
Continuous distributions

been available for about ten years, but until
recently the situation for the general case in
most of the other distribution families was not so
encouraging. Fortunately a number of new algorithms have appeared during the last year or so to
improve matters. The work of Dieter and Ahrens
(for example, [1, 6]) is particularly noteworthy

.

here; their acceptance-rejection methods for the
gamna distribution and the beta distribution [6]
have the attractive property of requiring nearly
constant time regardless of the parameter(s) of
the distribution.
4 I1LEMENTATION

Now how should we go about implementing our chosen
random-number generators? The range of issues
here is quite broad -- from choosing the level of

programming language to being careful, in an
assembly-language urd.fonrt generator, not to throw
away significant bits when converting the result

to floating-point. Let's look at some of the
questions from the top down.

1. What should the generator return? For most
applications the convenient form of output is a

vector of random numbers, and this means we will

be producing subroutines instead of functions. In
some cases a function might be better, but we
would want to balance this against the overhead
(both in progranining effort and storage space) of
adding the function foth to the library.
2. How should calling sequences (parameter lists)

structured? To integrate the routines as a
as in
be

library, we would put the comion parameters first,
RANDOM (X, N, [other parameters]).

3. How should we organize the way in which non—

uniform generators use a basic uniform generator

or generators? Here it is likely to be cleaner if

Uniform (0,1)

each routine which requires a source of uniform
randoii numbers actually incorporates its own.
This would consume little space and eliminate con-

Gaussian (0,1)

Exponential

siderable subroutine linkage especially in the

(and x2)
Beta (and F)
Gamma

nore complicated rejection algorithms. By removing "side-effect" interactions among different non—
unifonn generatcrs it should make complex simulation programs easier to debug.

Student's t
Discrete distributions
Uniform
Binomial

4. How should we handle starting values? In
order to reproduce results the user must be able

to set the starting value(s) (usually for the
basic uniform genenator( s)) and recover the
current value at any point in the sequence. For

Poisson

iumber of other distributions may suggest them-

.ves for specific applications, but any reason.e library should support those in the basic
;t.
each non-uniform distribution we of course
to use exact and efficient algorithms and
id such methods as inverse c .d . approximations

t

and the Central Limit Theorem. Clever exact
methods for the Gaussian and the exponential have

f.

the user who wants a "random" start we can provide
a routine which uses the system clock or some
other such source.
5. In what language should we proguam the
tors? This question may receive more varied

ers than the previous ones. Many generators,

especially uniform ones, have in the past been
coded in assembly language because the result runs

.

—3—

,

faster and because most higher-level languages
don't have the primitives for the operations involved. Now, however, it seems preferable to use
higher-level languages (such as FORTRAN or FL/I)

as much as possible. For one thing, this is the

only sensible way to approach portability from one
line of computers to another, and having machine-

independent generators will facilitate replication
of simulation studies, something we have largely
neglected. Another important consideration is the
correctness

of the implementation: assemblylanguage generators are likely to have more bugs,
and those bugs will be harder
isolate. One
IBM/360 assembler implementation of Marsaglia's
rectangle-wedge-tail algorithm for the Gaussian
distribution [L] provides a good example. Because

to

programmer misused one of the machine instructions, the generator produced an excessive number
the

of deviates with large magnitude (like 5 and 6!).
It's reasonable to admit that one can gain a good
deal of speed in most random-number generators by
coding them in assembly language, but the conclu-

sion has to be that we should never start at that
level. Program the generator in a higher-level
language and debug it thoroughly so that there

will be a well-understood version to compare the
assenbly-language one against.
6. What should we do about testing? The simple
answer, of course, is "Be thorough". This is old
advice, but many generators seem not to get a very
extensive
only test
mentioned

on

wor1ut. For

example, apparently the

applied to the Gaussian generator [4]
previously was a chi-squared test based
dividing the real line into 20 intervals of

equal

probability content. Since each tail

lies

entirely within one of these intervals, there was
no check on the tail part of the algorithm. A
simple probability plot would have exposed the
problem almost immediately. This example suggests

Documentation describing

mer will read

a precise statement of what the generator is and
what it produces. (It may be that this goes without saying, but an earlier (1 July 1973) edition of
the IMSL Library 1 Manual [11] did not
what
congruent ial generator was implemented in the subroutine GGU1; it was necessary to read the
assembly
code [7]. Fortunately this is no longer true in
essential details for
use are the calling sequence or parameter list,
restrictions on parameters (for example, the start-

tell

the latest edition.) Other

ing value), what other generators are used, and

the

default initialization.

To establish a generator's "pedigree", supporting.
documentation should report the specific algorithm
(with information on
efficiency), relevant
theoretical properties (especially for uniform
a non-uniform
generators, including any embedded
one), the sources of any previous implementations
on which the present one is based, arid the results
of testing. Together, these should give the user
an adequately detailed picture of the generator.

its

in

6. S1J?ARY

This paper has briefly endeavored to give an up-todate consumer ' s view of random-number generators.
Specific recormnendations cover uniform generators,
the composition of a basic library, and principles
of implementation and documentation. While a
number of actual exarnpls indicate that currently
available generators and libraries often fall short
of the best that we 1.a-iow how to do, it is reassuring to note that most of the tools needed for sub-

stantial improvement are ready to hand. We should

now expect (and perhaps demand) the gap between

possibility and prtice to close rapidly.

a natural strategy: the testing should be

designed to cover each segment of a complicated
algorithm (in addition to the performance of the
whole). This is valuable when the implementation
is in a higher-level language, and it is vital
when assembly language is involved. Testing also
should reveal something about the comparative
speed of the algorithm because this is often a
nre complicated question than theoretical calculations (of such things as the average number of
uniform deviates used in a rejection algorithm)

can answer.

recently

For
that on

Gentleman told me
a Honeywell 6000-series computer
example, W.

M.

the Gaussian algorithm of Brent [3] runs about 35%
slower than the 1964 algorithm of Marsaglia and
Bray

[15]. InfonBation like this is machinestill quite useful.

dependent but

5.

DOCUMENTATION

to documentation -- the most
important step in making a generator or library
accessible to users. Here the procedure is
Finally we come

but lapses are frequent enough
There are two basic
aspects: use of the generator and its "pedigree".

use is what every programand it should start with

iimnediately,

REFERENCES

[1] J. H. Ahrens and U. Dieter, "Computer Methods
for Sampling from Gariuna, Beta, Poisson, and

Binomial Distributions," Computing 12 (1974),
2232146.

[2] W. A. Beyer, R. B. Roof, and Dorothy
Williamson, "The lattice Structure of Multiplicative Congruential Pseudo-Random Vectors,"

Mathematics of Computation 25 (April 1971),
345—363.

[3] Richard P. Brent,

"Algorithm 488:

A Gaussian

Pseudo-Random Number Generator,"

——

tions of
706.

the ACM 17,

12 (December 1974), 704-

['4] lovick Edward

Cannon III, "Pseudo Random
Number Generators for Statistical Applications," Technical Report 69, Department of
Statistics and Computer Sciences, University
of Georgia, August 1971.

straightforward,

to demand a brief discussion.

[5] R. R. Coveyou and R. D. MacPherson, "Fourier
Analysis of Uniform Random Number Generators,"

Journal of the Association for Computing

Machiner1Tl967), 100—119.
[6] U. Dieter and J. H. Ahrens, "Acceptancerejection Techniques for Sampling from the

and Beta Distributions," Technical
Report 83, Department of Statistics, Stanford
University, May 29, 1974.
[7] David C. Hoaglin,
Remarks on the IMSL
Ganvna

Randan Number Generator GGtJ1," unpublished.

[8] David C. Hoaglin and David F. Andrews, "The
Reporting of Computation-based Result in

Statistics."

In revision for The Mierican

Statistician.

[9] David C. Hoaglin and Cordon Sande, "A Study
of Multipliers for Pseudo-Random Number
Generators with Modulus 231_i." Presented
Joint Statistical Meetings, St. Louis,

at

Missouri,

[10]

August 1974.

IBM Corporation, System/360 Scientific Subroutine Package (360A—CM-03X) Version III,
Programmer's Manual. H20—0205—3, 1968.

[11] International
Libraries,

Mathematical and Statistical

Inc.,

Manual, Edition

The IMSL Librax 1 Reference

(TTRAN IV,

S/370-

360).

[12] D. E. Knuth,

The Art of Computer Programming,

Volume 2: Seumerical Algorithms. Addison—
Wesley,

1969.

[13] C. Marsaglia, "Regularities in Congruential
Random Number Generators," Numerische
matik 16 (1970), 8—10.
[14] G. Marsaglia, "The Structure of Linear Congruential Sequences ," Applications of Number
Theory to Numerical Analysis (S. K. Zaremba,
editor)249—285. Academic Press, 1973.
[15] G. Marsaglia and T. A. Bray, "A Convenient
Method for Generating Normal Variables,"
SIAN Review 6, 3 (July 19614), 260—264.

S

