NBER WOR1NG PAPER SERIES

ROSACK Docnt No.

1

Semi-portability of FORTRAN Programs

Neil E. Kaden*
Virginia K1ema

Working Paper No. 103

Computer Research Center for Economics and Manageirrit
National Bureau of Economic Research, Inc.
575 Technology Square
Cambridge, Massachusetts 02139

Science

September 1975

PreJ±ninary: not for quotation

papers are disibuted infonrfly and in limited nunbers
only. They should not be quoted without written peiinission.

NBER working

caients

for

report has not undergone the review accorded official NBER publications;
particular, it has not yet been sunitted for approval by the Board of

This

in

Directors.

*

Computer Psearch Center. Research supported in part by National Science
Foundation Grant #DCR 75-08802 to the National Bureau of Economic Psearch, Inc.
NBER

1

Table of Contents

•

Ac]nowledgernents

.11

Pax't One

Part T.yo

3

References

10

Apperidi.x

11

11

Abstract

ansferring Fortran subroutines from one manufacturer' s machine to another
or from one operating system to another puts cerrtain constrains on the con-

struction of the Foran statements that are used in the subroutines. The
reliable performance of this mathematical software should be unaffected by
the host environment in which the software is used or by the compiler from

which the code is generated. In shorrt, the algori-thn is to he independent
of the computing environment in which it is run.
The subroutines of ROSEPAC1< (Robust Statistics Estimation Package) are

Fortran IV source code designed to be semi-portable where semi-portable is
defined to mean transportable with minimum change. *

Ac}oiowledgnents

The authors wish to thank J. Boyle and W. Cody for sharing their internal
document on progranmting conventions, J. Kirsch for his helpful suggestions
on documentation of subroutines, D. Hoaglin and G. RudenTian for their con-

structive criticism of this document, and Sheila Howard for her careful
typing of the manuscript.

*

J., "The Construction of Numerical Subroutine Libraries," SIAM
Review, Vol. 16, No. 1, pp. 36-46, January (1974).
W.

-1—

Semi-portability

of Fortran subroutines puts certain constraints on the

construction of Fortran statements, the declaration of variables, and the

representation of constants that are used in the subroutines. Many of these
constraints are needed for Fortran subroutines that are to be irribedded in
applications subsystems that are written in another language, say FL/i.
Inevitably, the nnerica1 algebra algorithms themselves are strengthened
when their perfonnce is unaffected by the arithmetic of the rich±ne on
which they are used and the Fortran compiler by which their code is generated.
The ruJ.es for structured progranuring [1,2,31, arid structured docunentation

this docnt) should be followed insofar as possi-

(see Part

Two,

ble.

corrnts within the program or subroutine should be sufficient to

The

inform

Section X

of

the user about input parameters, output parameters, temporary storage

parameters, error exits, and the algorithm that the program

implements.

This dociiint presents certain suggestions for prograrrming that will tend

toward requirements for semi-portability of ANSI Fortran IV

(as

described in

CACM, Vol. 7, No. 10, October '6.) subroutines and programs. We also suggest
certain conventions for cormients

and

general formatting of the Fortran code.

By "formatting" we mean the spacing and indentation that determine the

general appearance and readability of the code. Such formatting is suggested
to help the reader or the user understand the algorithm, the program, and the
flow of control within the program.

Part One

The suggestions for prograrrming are

I.

C11N storage should not be used for arrays. This

one does not use C)M1)N.
II.

is

not

ANSI restriction, but driver programs become simpler
write, and the use in a paged envirorurnt is enhanced

an

if

to

All array arguments should have adjustable dimensions. These
dimensions should be made explicit in the declarations of the
formal parameters for each subroutine. For example,

—2—

REAL A(NN,N)

not
PEAL

A(NM,l)

III.

EQUIVALCE statements should not be used.

IV.

Certain

V.

Do not use rrniltiple entry points or non-standard returns.

VI.

Be sure that the precision of any Fortran library routine

Fortran compilers do not distinguish more than six

characters of an identifier. Hold identifiers to six characters or fewer.

or built-in function is explicit in all statements. For

example, DABS, not ABS, for absolute value for long precision computing. Do not use mixed mode arithmetic or assune
there is an implied conversion anywhere, riot even for con-

stants. For example

DØUBLIE PRECISION X

XX+

l0.ODO

not
DØUBLE PRECISION X

XX+
VII.

10.0

Constants that are used in iterations or convergence criteria
should be functions of the machine's precision, i.e., the
smallest floating point number, , representable in the machine
for which the floating representation of l+c>l. Certainly, a
constant that cannot be converted precisely on the machine
should never be used. For example, .1, is representative of
such numbers.

VIII. Test cases nnist be devised so that data can be converted uniformly
on all target machine. The word length of the machine determines
the truncation of the internal representation of floating point
numbers, and conversion routines do not treat floating point
numbers uniformly. The integers are treated uniformly with respect
to conversion so long as they lie within the precision range of arithmetic of the computing machine. One suggestion for portability for
test cases used as input numbers is to read them in as integers and
then DFWAT to get the floating point representations.
IX.

Obscure underflows can often produce side effects that give
divide checks or overflows. This problem is particularly acute
because the range of arithmetic on many machines is not suretric
about zero. For example the range of arithmetic on the IBM 360 /

370 machines is about 10 > x> l08. That an algorithm will
exhibit overflow, underfiow, or divide check problems is often
not known in advance. However, some linear systems routines have
this problem when an inner product is formed or when multiple
divides are encountered. Be prepared to isolate such problems.

—3—

solution is to reorder arithmetic expression. Another
solution is to resort to extended precision arithmetic for
those critical sections of code.
One

X.

The usual rules for separate sections for error handling
and input-output that are required for applications subsystems are equafly applicable for semi-portable Fortran
programs. The error handling from the subroutines should
be uniform. The input-output should be confined to main
programs or special 1-0 subroutines; that is to say, computation subroutines should be 1-0 free. The goal of the
error recovery is to permit computation to continue without
resorting to system termination.

XI.

We expect the subroutines in ROSEPACK to be compiled with

Fortran compilers with the highest level of optimization.
We have not used hand optimization in the subroutines

Part 'Io
The suggestions for formatting are

I.

Identifiers
Identifiers, i.e., variable names, should correspond to
default declarations in Fortran. Ho.iever, explicit declarations should be written for each identifier.
Variables from the calling sequence, internal variables, and
function names should all be declared separately. For a

suggestion on how to accomplish this see X Internal L)ocumen-

tation

Section B (PARAMETERS), Section C (LOCAL VARIABLES),
D (FUNCTIONS) of the description of the Prologue.

and Section

II.

Labels

If the order of labels within a subroutine is not linear the
convention used should be explicitly described. This order-

ing of statement labels should be linear and could proceed
in multiples of 10 for interior program sections. The next
level of program section could proceed as 100, and perhaps the
next as 1000.
Do not use unreferenced labels.
Code for error exits should be surrounded by coirurnts and
located at the end of the program or subroutine. The labels

for error exits should be 2 or 3 digits, the first of which
is 9, the last non-zero.

One format statement may be used by rrore than one print staternent in a program. Therefore we suggest that all format statements be labeled with 4 digit n.mibers the last of which is nonzero and placed after RETURN and before END of the program.

Preferably all input-output should be written in subroutine

a

DATA statement be used to fix units
We suggest that
a
DATA statement be made particular
of 1-0 and
given

for!n.

that this
installation.

to

The variables containing this 1-0 unit information should be
passed as parameters to all subroutines using these 1-0 units.
This device allows a global change of an 1-0 unit without
recompiling individual subroutines.

III.

Use of blank spaces
There should not be extra blank spaces around dummy variables

or constants ThO loops. Blank spaces should delimit symbols
in assiiment statements. Blank spaces should be used wherever
such use will enhance readability of elements of ecpressions or
statements.

IV.

Tab Spacings

Throughout this document we are assuming tab setting in columms

1, 7, 10, 15, 20, 25, etc.
V.

Continuation Characters

Second and subsequent lines of all continuation statements should
be numbered 1 through 9, then A through Z in columm 6. The text
of each continuation statement should be indented one tab space

from the initial line of the statement.

VI.

DO loops

All D0 loops should be surrounded by comment statements which
may be blank. Text conunents should follow a blank comment state-

ment. If more than one statement is in the range of a DO loop,

the closing statement of the DO loop should be a CONTINUE. This
CONTINUE should be unambiguous. Statements between DO and CONTINUE

should be indented one additional tab space to correspond to a block

structure.
Inner loops should be indented one tab space to the right of their
surrounding outer loop.
For examples of indentation of DO loops
Appendix I.
VII.

see the examples in

DATA Statements

set installation-dependent

Data statements should be used to
constants, such as data-set numbers

for I/O, and machine precisions, underflow tolerances, or other machine-dependent constants.

See X, Internal 1)zcumethation, Section L, for more details.
If a non-numeric character string must be used in a DATA statement, it should be packed as one character per machine word

and always stored in an array.

—5—

VIII. Structured programming
The prograirunirig and fonnattirig conventions that we describe
are similar to structured programming in the following ways:

1. format for readability and understanding
2. indentation for major and minor loops
3. array dijrnsions are adjustable
Li. temporary storage arrays are passed as parameters

5. documentation is sictured such that it is contained
within the routine.

IX.

Printed output

All printed output should be fonratted such that it is not
greater than 8 1/2 inches in width. Most line printers print
10 characters per inch, and 80 characters per line allows ample
margins. This will eatly aid in reproduction of the output.
X.

InterTlal icumentation
All For'an programs should be well doc.mented by liberal use
of comment statements. Proper doci.mntation will enhance readability and appearance of the code, improve understanding of the
algorithm used, help ensure proper use of the program, and aid
in future modifications. When semi-portability is also considered,
proper documentation serves to isolate those portions of the code
which are installation-dependent.
In-line documentation of Fortran programs can be considered in
two major sections, the Prologue and the Program-flow comments.
The latter consists of the corrunent statements embedded within
the code describing how the algorithm is being carried out as
the flow of control passes from statement to statement. The
former consists of certain non-executable FORTRAN statements

found at the beginning of the subprogram which fully describe the
proper use of the software, as well as infcrmnation concerning
its development. Any user familiar with the guidelines has the
added advantage of 1owing where to find specific information
concerning the program. The Prologue also identifies and isolates
installation-dependent aspects of the program and thus enhances
semi-portability. The Prologue is the major docimentation for
the use of the program subroutine.
Program-flow comments should be delimited by special characters
to enhance their readability and appearance. In ROSEPACIK the
colon C:) is used. Such comments should also follow the rules
for statement indentation described elsewhere in this document.
In most cases, the text of the comment should be preceded and

followed by a string of 10 special characters (colons). At least

—6—

blank space, but not more than three blank spaces, should
be put between the special character strings and the text of the
comment. If this method is used for a comment extending over
several lines, all lines should have a "C" in colturm 1, arid all
but the first line should be indented one additional tab (beyond
the current level of indentation).
one

Building on the suggestions of Boyle and Cody, an alternative
method of delimiting comments, recommended for important comments
or those extending over several lines, is to surround them by
a "box" of special characters. The following is an example of
what is meant by a "box":
C

::
C

THIS

ISACONT

:

Blank comment statements (i.e., comment statements containing
blanks in colizins 2 through 72) may be used wherever their use
enhances the readability of the program.
The statement irrmediately before the END statement should always
be a comment statement delimiting the end of the program and containing the name of the program. An example follows:
C

:::::::::::

LAST CARD OF (NAME OF SUBROUTINE) :::::::::::

END

The Prologue consists of the declarations of the calling sequence
and variable names of the subprogram, a number of sections of

text on the subprogram, and any flATA or EQUIVALCE statements.

It contains a number of headings denoting the different logical
sections of the Prologue. The headings are coimnt statements
with the character "k" in columns 7 through 11 and the heading name
beginning in column 12 and followed by a colon (:). A blank comment
statement should not immediately follow a heading. If the section
denoted by the heading line is empty, the heading should be followed
by a comment statement containing "NONE" in columns 7 through 10 and
then a blank comment statement.

The different headings, in the order they should appear, are:
-PARAMETERS
-LOCAL VARIABLES

-FUNCTIONS
-PURPOSE
-PARAMETER DESCRIPTION
-APPLICATION AND USAGE RESTRICTIONS
-ALOORITHM NOTES
-REFERENCES
-HISTORY
-GENERAL
-BODY OF PROGRAM

—7—

Three delimiter lines, consisting of a blank conment statement,
a cnment statement consisting of the special character colon

(:) in co1uns 7 through 72, and then a second blank coirment
statement, should occur mneidately before the purpose heading
arid mnediately after the GENERAL section. All lines between
these delimiters should be comnnt statements. When colms
73 through 80 of each card contain serialization or identification characters, this gives a box-like appearance to the part
of the Prologue containing text.
An exanle of two programs following these guidelines is in
Appendix I.

is a brief description of each section of the
Prologue. Note that no blank connt statements should occur
What follows

until after the FUNCTIONS

section.

A. CALLING SEQUENCE
The SUBROUTINE or FUNCTION statement should be the

first line of the subprogram. Blanks should be used
to enhance readability.

B. PARA1TERS
Declaration

statements should be grouped by type, i.e

first INTEGER, then REAL, then DØUBLE PRECISION, or REAL*8,
then

REAL*l6, then Cø'PL'(, CøMPLD*32, then LØGICAL.

Within

each type grouping, variable names should be listed in
the order they occur in the calling sequence. By parameters, we mean all of the variable names appearing in
the calling sequence.
C. LOCAL VARIABLES

with the preceding section, declaration statements are
grouped by type, and in the same order. Within each type,
variable names should be listed alphabetically.
ALL variables used in the program should be explicitly
declared.
As

D. FUNCTIONS

All functions called by the program should be explicitly
declared. Declaration statements are grouped by type.
E. PURPOSE

Briefly describe the purpose of this subprogram. Give
references when necessary. More detail can be given in
later sections.
F. PARAMETER DESCRIPTION
This section contains 3 subsections. The first describes
input parameters, the second describes output parameters,
and the third subsection describes parameters used for

temporary storage by the subprogram. If the contents of
any parameter variable can be changed by the subprogram,

—8—

it should be considered an output parameter. See
the examples in Appendix I for the forirat, keywords,
punctuation and indentation used in this section.
G. APPLICATION AND USAGE RESTRICTIONS

If any other programs in this package can call this

subprogram, or are called by it, they should be desscribed here. If this subprogram is part of a group
of programs which are called in some specified order,
this should also be included. Give references except
when a reference is implicit, as with another member
of the same package.

Also included in this section are any warnings about
special cases or possible errors which can occur if there
are errors in the subprogram call. Warnings about misuse
of tolerance parameters belong here. The entry in
PARAETER DESCRIPTION should refer the reader to this
section where

H.

applicable.

ALGORITHM NOTES

Anything special about the algorithm used or its implernen-

tation should be listed here. Any

special

conventions

labeling or camienting should be
regarding
mentioned. If there is anything special about error
ling which has not yet been mentioned, it should be
described here.
statement

I.

hand-

REFERENCES

elsewhere in the documentation, as well as
any other references pertaining to the subprogram, should
References from

be listed.
J. HISTORY

The author of this subprogram, as well as the date and place

of origin should be listed. If the subprogram is a transla-

-don of a program in another larigiiage or is based on another
program, a reference should be given. If the program has
been rrdified since it was written, the date and person

making the itodification should be noted. If this subprogram
has been released as part of a subroutine library, the current
release date of the library should be given.
K. GENERAL

If this

under research supported by
a grant requiring ac]<owlednent, the required information
should occur here. The person to contact concerning coninents
and problems with the subprogram should have his address in
subprogram was developed

this section.

—9-.

L. DATA and EQUIVALANCE Statements

Following the second occur'ence of deliting comment
statements (a blank comment statement, a cojmnt statement with colons in colurrris 7 through 72, and a second

blank colTrnent statement) is where all DATA and EQUIVALENCE

statements should occur. If a DATA statement contains an
installation-dependent constant, coimnt statements explain-

ing its value and mentioning the installation's desiation,

should precede the DATA statement. Those conunent statements
should conform to the standards of program-flow comments.
All DATA statements should precede any EQUIVALENCE staements.
M. BODY OF PROGRAM

This heading denotes the end of the Prologue and the beginning
of the program body.

—10—

References

El] Dahl, 0 .H, Dijks'a, E . W., Hoare, C .A. R., S1ictured Pograimning, Academic
Press, (1972).
[2]

Kerriighan, B.W., Plauger, P.J., "Prograiiing Style: Examples and CounterExamples," ACM Coriuting Surveys, Vol 6, No. J., pp. 303-319, December,
(197'i.).

[3]

Kernighan, B. W., Plauger, P. J.,

Telephone

Laboratories (l97L.).

"The Elements of Proanimirig Style," Bell

-UAppendix

This appendix contains listings of two subroutines that are samples of
candidates for inclusion in ROSEPACK. The reader is reminded that we

are relying on Fortran compiler optfriization of sub-expressions within
loops.

1INOO01O

SUBROUTINE I1INSOL(NM,N,V,W,IP,B,RKTOL,IERR,RV1)

11N00020
!'IIN0003O

C
C

C

C
C
C
C
C
C

C
C
C
C
C

C
C
C
C
C
C
C
C
C
C
C
C
C

*****PARMIETERS:
INTEGER NM, N ,IP, IERR
REAL*8 V(Nt•1,N),W(N),B(NM,IP),RKTOL,Rv1(N)
*****LQCAL VARIABLES:
INTEGER I,J,K
REAL*8 RKTOL1,X,Z

MIN0oOO
MIN0005O
r1IN00060
fiIN0007O

MIN000BO
MIN0009O

*****FUNCTIONS:

NONE
:

IINOO100

:::::: : : : :

NINOO1lO

: : : : : : : : : : : : : : : : : : : ::::::: : : : : : : : : : : : : : : : : : : : : : ::::: :MINOO 120
tiINOGl3O

*****PURPOSE:
THIS SUBROUTINE DETERMINES A CANDIDATE SOLUTION TO THE LINEAR
T

C
C
C
C
C
C
C
C
C
C
C
C
C
C
C

T

REAL Ii BY N RECTANGULAR MATRIX, FORMING U B RATHER THAN U,E!AS
ALREADY BEEN PERFORMED. THIS CANDIDATE SOLUTION IS BASED ON THE
RANK TOLERANCE PARAMETER, RKTOL, OR THE DEFAULT, 2.ODO**(_26),
WHICH IS THE SQUARE ROoT OF THE MACHINE PRECISION 2.ODO**(_52).

c
C
C

C
C
C
C

c
C
C
C
C
C
C

NINOO18O
tIINOO190

NINOO200
M1NOO21O
N1N00220
P11N00230

NINOO2O
NINO02O

*****PARANETER DESCRIPTION:
ON INPUT:
NM MUST BE SET TO THE ROW DIMENSION OF THE TWO DIMENSIONAL
ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
DIMENSION STATEMENT;

N IS THE NUMBER OF ROWS OF B, AND THE ORDER OF V;
V CONTAINS THE SQUARE MATRIX V (ORTHOGANAL) OF THE SINGULAR
VALUE DECOMPOSITION;

W CONTAINS THE N (NON—NEGATIVE) SINGULAR VALUES OF A (THE
DIAGONAL ELEMENTS OF S). THEY ARE UNORDERED;

M1U00260
11U00270
MINOO28O

M1N00290
MINOO300
NINOO31O
M1N00320
M1N00330

t1IN0O30
11N00350
N1N00360
M1N00370
U1N00380
MINOO39D

IP IS THE NUMBER OF COLUMNS OF B;

MINO000
MIN0O41O
T

N CONTAINS THE RECTANGULAR MATRIX U B;

FKTOL IS THE RANK TOLERANCE WHICH WILL BE USED. IF RKTOL IS
NOT POSITIVE, THEN THE DEFAULT WILL BE USED.

MINOO46O
MItJOO.47O

UINOO9O

V REMAINS UNCHANGED;

W CONTAINS THE PSEUDOINVERSE OF THE DIAGONAL MATRIX S.
ANY SINGULAR VALUES THAT ARE LESS THAN RKTOL TIMES THE
LARGEST SINGULAR VALUE ARE SET TO ZERO IN THE PSEUDO—
INVERSE;
B HA.S BEEN OVERWRITTEN BY THE SOLUTION X;

IERR IS SET TO
ZERO FOR NORMAL RETURN,
—1

MrNOOI42O

MINOO3O
MINOO!O
NINO045O

lIN008O

ON OUTPUT:

C
C

:11N00160

SSTEf1 AXB, AFTER THE SINGULAR VALUE DECOMPOSITION AUSV OF' A NINOO17O

C

C

MINOOV4O
NINOO15O

IF THE MAXIMUM SINGULAR VALUE IS ZERO (INDICATING
A ZERO A—MATRIX IN THE SINGULAR VALUE
DECOMPOSITION).

11U00500
!11N00510
M1N00520

fl1N00530
MINOO54O
HINOO55O

NINOO6O
H1N00570
NINOOS8O

1INOO59O
rltNOO600
MINOO61O

M1N00620
N1N00630
M1N00650

C
C
C
C
C
C
C
c
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C

C
C
C
C
C

o
o
C

M1N00660

RVI IS A TEMPORARY STARAGE ARRAY.

F11N00670

*****APPLICATION AND USAGE RESTRICTIONS:
IT IS RECOMMENDED THAT THE SUBROUTINE MINFIT (1) PERFORM THE
SINGULAR VALUE DECOMPOSITION.
THE IERR PARAMETER SHOULD BE CHECKED BEFORE CALLING MINSOL.

C
C
C
C
C

c
C
C

C
C
C
C
c
C
C
C
C
C
C
C

C

*****BEFERENCES:
(1) ARGONNE NATIONAL LAB., FORTRAN SUBROUTINE MINFIT, ANLF233S.
(2) BECKER,R.,KADEN,N., AND KLEMA,V., 'THE SINGULAR VALUE
ANALYSIS IN MATRIX COMPUTATION', MBER WORKING PAPER NO. L6,
(JULY i97Z)
(3) GOLUB,G.H., AND REINSCH,C.,'SIt4GULAR VALUE DECOMPOSITION

IIINOO800
IIINOO81O
tiINOO82O
111N00830
t1INOO8i4O

tIINOO85O

M1N00860
AND LEAST SQUARES SOLUTIONS,IN J.H. WILKINSON AND C. REINSCH MINOO87O
(EDS.) HANDBOOK FOR AUTOMATIC COIIPUTATION,VOLUME II:LINEAR
r4INOO8O
ALGEBRA, SPRINGER VERLAG,.1314—151 (1971); PREPUBLISHED IN
M1N00890
NU1ER. MATH. 14,O3_t12O (4970).
MINOO900
MINOO91O
*****HISTQRY:
MINOO92O
MINSOL IS BASED ON CODE WRITTEN BY FRED CIARAMAGLIA (NBER/COtIPUTERMIN0O93O
RESEARCH CENTER; MAY , 1973).
1IN0O90
N1N00950
ADAPTED BY NEIL KADEN (NBER/coMpuTER RESEARCH CENTER) JUNE

DATE LAST MODIFIED: JUNE

ii, 1975.

,197!IriCo
Jfl7

ltN3fl99J

1I 1 )fl

QUESTIONS AND CO1MENTS SHOULD BE DIRECTED TO:
MINO1O1O
SUPPORT STAFF MANAGER
MINO1O2O
COMPUTER RESEARCH CENTER FOR ECONOtIICS AND IIANAGEMENT SCIENCE ?11N01030
NATIONAL BUREAU OF ECONOMIC RESEARCH
M1N010140
575 TECHNOLOGY SQUARE
MINO1O5O
CAMBRIDGE, MASSACHUSETTS 02139.
1IN01060
MINO1O7O
DEVELOPMENT OF THIS PROGRAM SUPPORTED IN PART BY
MINO1O6O
NATIONAL SCIENCE FOUNDATION GRANT GJ—1154X3 AND
flINOlO9O
NATIONAL SCIENCE FOUNDATION GRANT DCR75—08802
UINO1100
TO NATIONAL BUREAU OF ECONOMIC RESEARCH, INC.
IIINO111O
1IN01120
: : : : : : : : : : : : : :
: : : : : : : : :::::::: : : : : : : : : : : : : : :::::: : : : : : : : : : : : : : : :MINO 1130
r1IN01140

:::::::::: RKTOL.1, FOR THESE APPLICATIONS, IS A MACHINE DEPENDENT MINO11SO

PARAMETER BASED ON THE SQUARE ROOT OF THE RELATIVE PRECISION
OF FLOATING POINT ARITUMATIC.
MACHE? = 16.ODO**(_13) FOR DOUBLE PRECISION ARITHMETIC
ON S360 AND S370. :
DATA RKTOL1/Z3ALW000000000000/

:::::::::

*****BODY OF PROGRAM:
IERR
o
IF (RKTOL .LE. O.ODO) RKTOL RKTOL1
:::::::::: FIND MAXIMUM ELEMENT OF W :::::::::;
Z
0.000

C

DO 750 J = 1, N
x
W(J)
IF (X .LE. Z) GO TO 750
Z
X
750 CONTINUE
c

MINOO7t1O

MINOO72O
M1N00730
SETTING THE RANK TOLERANCE SHOULD ONLY BE DONE IF THE USER KNOWS MINOO7!O
THE SINGULAR VALUES OF THE A—MATRIX WITH RESPECT TO THE CERTAINTY M1N00750
OF THE DATA.
M1N00760
M1N00770
*****ALGQRITH1 NOTES:
N1N00780
NONE
MINOO79O

C
C

M1N00680
M1N00690
MINOO700

MINO116O
111N01170

MINO118O
tIINO119O
HINO1200
r'IINO121O

H1N01220
£11N01230
f'1INO124O

fIINO125O
rIINO126O

M1N01270
?11N01280

1INO1290
UINO1300
11N01310
1IN0 1320
tIINO133O

IF (Z .EQ.0) GO TO 999
:::::::::: FORM PSEUDO INVERSE OF DIAG(W) ::::::::::

C

800 J
1, N
x
W(J) / Z
IF (X .LE. RKTOL) GO TO 790
1.ODO / W(J)
w(J)
GO TO 800
W(J) = O.ODO
790
800 CONTINUE
C
:::::::::: FORM X (RETURNED IN B)
DO

DO 900 J

MINO1 380
'1IN01 390
HINOI 1400

HINO1111O
HINO 11420
1 IN 011130

M1N0111110

C
810

1, N

w(I) *

M IN 01 1450
H IN 01 1460
N IN 01 1470

B(I,J)

HINO 11180

C

DO 890 I = 1,
X
O.ODO

MINOl 350
MINOl 360

M1N01370

1, IF

DO 810 I
RV1(I)
CONTINUE

MINOI 3110

MIND 11490
H IN 01500

N

HINO151O
MINOl 520

C

MINO 1530

DO 850 K
1, N
X = X + V(I,K) * RV1(K)
CONTINUE

850

N IN 015140
H IN 01 550

MIN0 1560
HINO1 570

C
B(I,J)
CONTINUE

890

X

MIND 1 580
1 IN 0 1 590

C

1 IN 0

900 CONTINUE

1 600

HIND 1610

C

GO TO 1000
ERROR IF MAX SINGULAR VALUE

C

999 IERR =

—1

RETURN TO CALLING PROGRAM

C

LAST CARD OF MINSOL
END

::::

ri

INO 1620

IIINO 1630
IINO1 6140
II N 01 650

MINO1 660

1000 RETURN
C

0 ::

N IN 01670

MINO168O

SUBROUTINE LUDCMP(MN,M,N,A,IHTTC,ICOL,IROW,IERR,ICMAX)
*****PARAtIETERS:
INTEGER tiN,M,N,IHTTc(N),IcoL(N),IRow(r1),IERR,ICMAx(N)

C

REAL*8 A(MN,N)
*****LQCAL VARIABLES:
INTEGER I,nIIN,IPIVOT,ITEMP,J,MAXCOL

C

REAL* AMAX,RATIO,TEMP
*****FUNCTIONS:

C

INTEGER IIINO

REAL*8 DABS
C
C
c
C
C
C
C
C

c
C
C

C
C
C

LUD000IO
LUD0002O
LUD0003O
LUDOOO4O
LUD0005O
LUD0006O
LUD0007O
LUD0008O
LUD0009O
LU000100
LUDOO11O
::::LUDOO12O
LUDOO13O

*****pURPOSE:

LUDOO1O

THIS SUBROUTINE DOES AN LU DECOMPOSITION ON THE REAL N BY N
RECTANGULAR MATRIX A, WITH MODIFIED COMPLETE PIVOTING, AND
RETURNS BOTH THE STRICT LOWER TRIANGLE OF L AND THE FULL
UPPER TRIANGLE OF U.

LUDOO15O

*****PARMIETER DESCRIPTION:
ON INPUT:

LUDOO200

LUDOO16O
LUDOO17O
LUDOO18O
LUDOO19O
LUDOO21O

LU00022O
LUDOO23O
LUDOO24O

C.

NM MUST BE SET TO THE ROW DIMENSION OF THE TWO—DIMENSIONAL
ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
DIMENSION STATEMENT;

C
C

H MUST BE SET TO THE NUMBER OF ROWS IN THE MATRIX;

LU00027O

c
C
C
C
C
C
C

C
C

C
C
C

C
C
C
C

C
C
C

C
C
C
C

C
C
C
C
C
C
C
C

C
C

U

MUST BE SET TO THE NUMEH OF COLUMNS IN THE MATRIX;

LUDOO2O
LUDOO26O

LUDOO2SO
LUDOO29O

LUDOO300

A CONTAINS THE MATRIX TO BE FACTORED BY THE LU—DECOMPOSITION
WITH COMPLETE PIVOTING;

LUDOO31O
LUDOO32O
LUDOO33O

IHTTC IS SET SUCH THAT IF IHTTC(J) IS LESS THAN ZERO THEN THE LUDOO3O
LUDOO3SO
J—TH COLUMN OF THE INPUT MATRIX CANNOT BE PIVOTED INTO
THE FIRST N COLUMNS OF ITS LU—DECOMPOSITION. ALL ELEMENTS LUDOO36O
LUDOO37O
OF THIS VECTOR SHOULD BE SET TO ZERO TO INSURE NORMAL
LLTDJ0380
PIVOTING;
LUDOO39J
LUDOOOO
ON OUTPUT:
LUDOO1O
LUD001420
A CONTAINS THE L—MATRIX AND THE U—MATRIX AS FOLLOWS:
A( ROW(I),COL(J) ) FOR I LESS THAN OH EQUAL TO J CONTAINS LUDOO3O
LUDOO!4O
THE (I,J) ELEMENTS OF THE UPPER TRIANGULAR U—MATRIX;
LUDOO5O
A( ROW(I),COL(J) ) FOR I GREATER THAN J CONTAINS THE
SUB—DIAGONAL (I,J) ELErIENTSOF THE L—NATRIX. THE DIAGONAL LUDOO6O
LUDOO7O
OF THE L—UATRIX CONTAINS ALL ONES;

LUDOOt8O

IROW

REFLECTS THE ROW PIVOTING PERFORMED. IF IROW(J) IS
EQUAL TO K THEN THE J—TH ROW WAS PIVOTED INTO THE K—TN
ROW—POSITION. SEE ALSO THE OUTPUT DESCRIPTION OF A;

LUDOO49O

LU000500
LUDOO51O

LUDOO52O
ICOL REFLECTS THE COLUMN PIVOTING PERFORMED. SEE ALSO THE
OUTPUT DESCRIPTION OF IROW;

LUDOOS3O
LUDOO54O
LUDOOS5O

LU00056O
IERH IS SET TO ZERO FOR NORMAL EXITS.
LUDOO57O
IT IS SET TO K, WHERE K IS AU INTEGER DENOTING THE
CURRENT ITERATION. IF NO ACCEPTABLE PIVOTS COULD BE FOUND LU00058O
LUDOO59O
(AN ACCEPTABLE PIVOT IS A NON—ZERO ONE WITH THE
LUDOO600
CORRESPONDING ELEMENT OF IHTTC NON—NEGATIVE).

C

IF AN ERROR EXIT IS TAKEN, THE DECOMPOSITION HAS ONLY

C

BEEN PERFORMED FOR K—i ITERATIONS.

LtJDOO61O
LUDOO62O
LU DO 0 6 30

C
C
C
C
C
C
C
C
C
C

ICMAX IS USED FOR TEMPORARY STORAGE BY THE SUBROUTINE.

LUDOO6O

*****APPLICATION AND USAGE RESTRICTIONS:
LUDCMP CAN BE USED IN SOLVING A LINEAR SYSTEM AXB.

LUDOO65O
LUDOO66O
LUDOO67O

LUDOO6O
SPECIAL CARE SHOULD BE EXERCISED IN THE USE OF THE PARAMETER

LUDOO69O
LUDOO700
LUDOO71O
*****ALGQRITH?1 NOTES:
LUDOO72O
LUDCr-IP USES INDIRECTION IN FORMING THE LMATRIX AND THE U—MATRIX LUDOO73O
TO AVOID ACTUALLY INTERCHANGING ROWS AND COLUMNS IN MAIN STORAGE. LUDOO74O
IHTTC.

C
C
C
C
C
C

LUDOO75O
LUDOO76O

*****REFERENCES:
NONE

*****HISTORY:
WRITTEN BY NEIL KADEN (NBER/CONPUTER RESEARCH CENTER) JULY 31,

C
C
C
C
C

197L.

LUDO'J820

DATE LAST MODIFIED: JUNE 17, 1975.

*****GNRAL:

C
C
C
C

LUDOO83O
LUD0O84O
LUDOO85O

QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO:
LIJDOO56O
SUPPORT STAFF MANAGER
LUDOO87O
COMPUTER RESEARCH CENTER FOR ECONOMICS AND MANAGEMENT SCIENCE LUDOO88O
NATIONAL BUREAU OF ECONOMIC RESEARCH
LUD00890
575 TECHNOLOGY SQUARE
LUDOO900
LUDOO91O
CAMBRIDGE, MASS. 02139.
LUDOO92O
DEVELOPMENT OF THIS PROGRAM SUPPORTED IN PART BY
LU00093O
NATIONAL SCIENCE FOUNDATION GRANT GJ—1154X3
LUDO09O
TO NATIONAL BUREAU OF ECONOMIC RESEARCH, INC.
LUDOO9SO

C

C
C
C
C
C

C
C

C
C
C

:

LU000960
: : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :::::: : : : : : : : : : : : : : : : : : : : : : : : : : : LUDOO97O

*****BODY OF PROGFAM:
ThIN = 1INO(tl,N)
IERR
0

C

DO 10 I1,M
IROW(I) =
10 CONTINUE

I

LUDOOYbO
LUDOO99O
LUDO1000
LUDO1O1O
LUDO1O2O
LUDO1O3O
LUDO1O!10

LUDO1OSO

C

LUDO1O6O

C

DO 20 I=1,N
ICOL(I)
20 CONTINUE

LUDO1O7O
LUDO1O8O
LUDO1O9O

I

LIJDO1100

C
C

::::::::::BEGINNINGQFOUTERLOOP::::::::::
DO

110 IPIVOT=1,IMIN

C

DO !40 J=IPIVOT,N

ICMAX(J)

IPIVOT

C
DO

30 I=IPIVOT,M
IF

1

30

4O

(DABS(A(IROW(I),ICOL(J))) .LE. DABS(A(IROW(

ICMAX(J)),ICOL(J)))) GO TO 30
ICMAX(J) = I
CONTINUE

c

c

LU00077O
LUD00780
LUDOO79O
LUDOO800
LUDOO81O

CONTINUE

LUDO111O
LUDO112O
LUDO113O

LUD011O

LUDO115O
LUDO116O
LUDO117O
LUDO1ibO
LUDO119O
LUDO12CO
LUDO121O
LUDO122O
LUDO1230
LUDO124O
LUDO125O

MAXCOL
0
AMAX
0.ODO

LUDO1260
LUDO127O
LUDO 1280

DO 50 J=IPIVOT,N
IF (IHTTC(ICOL(J)) .NE. 0) GO TO 50
TEMP = DABS(A(IROW(ICMAX(J)),ICOL(J)))
IF (TEMP .LE. AMAX) GO TO 50
AMAX = TEMP
MAXCOL = J
CONTINUE

50
C

IF (MAxC0L .EQ. 0) GO TO 99
IF (MAXCOL .EQ. IPIVOT) GO TO 60
::::::::::COLUMNEXCHANGE::::::::::
ITEMP = ICOL(IPIVOT)
ICOL(IPIVOT) = ICOL(MAXCOL)
ICOL(UAXCOL) = ITEMP
CONTINUE
IF (ICMAX(MAXCOL) .EQ. IPIVOT) GO TO 70
::::::::::HOWEXCHANGE::.:::::::

C

60
C

LUD0100
LUD011O

LUDOV42O

LUD013O

LUDO10
LUDO1!450

ITEM?
IROW(IPIVOT)
IROW(IPIVOT) = IRow(ICMAxUIAxC0L))
ITEMP
IROW(ICMAx(MAXCOL))
CONTINUE
::::::::::PIVOTING ACCOMPLISI-IED::::;:::::
IF (IPIVOT .EQ. Ii) GO TO 110
ITE?IP
IPIVOT + I

70
C

LUDO1.!460

LUD0170

C

DO 90 I=ITEMP,M
RATIO = A(IROW(I),ICOL(IPIVOT)) / A(IROW(IPIVOT),ICOL(
1

- IPIVOT))

-

A(IROW(I),ICOL(IPIVOT))

RATIO

IF (IPIVOT .EQ. U) GO TO 90
c
Do

80 J=ITErIP,N
A(IROW(I) ,

ICOL(J))

A(IROI(I) ,

IROW(IPIVOT),ICOL(J))

1

CONTINUE

80
C

CONTINUE

90
C

110 CONTINUE
C
C

:::::::::.ENDOFOIJTERLQOP::;:::::::
GO TO 100
::::::::::NO NON—ZERO PIVOT FOUND::::::::::
99 IERR = IPIVOT

C

ICOL(J))_RATIO*A(

LUDO1480
LUD01L90
LUDO1500
LUDO151O
LUDO1S2O
LUDO1S3O
LUDO15LO
LU301550
LwD01560
LUDO157O
LUDO158O
LUDO159O
LUDO1600
LUDO161O
LUDO162O
LUDO163O
LUDO164O
LUDO165O
LUDO16ÔO
LUDO167O
LUDO168O
LUDO169O
LUDO1700
LUDO1710
LUDOl 720

100 RETURN
C

LUDO129O
LUDO1300
LUDO131O
LUDO132O
LUDO133O
LUD0134O
LUDO13SO
LUDO136O
LUDO137O
LUDO138O
LUDO139O

::::::::::LASTCARDOFLUDCMP::::::::::
END

LUDO173O
LUDO17LO
LUDO175O

