NBER WORKING PAPER SERIES

SOLVING THE MULTI-COUNTRY REAL BUSINESS CYCLE MODEL USING
ERGODIC SET METHODS
Serguei Maliar
Lilia Maliar
Kenneth L. Judd
Working Paper 16304
http://www.nber.org/papers/w16304

NATIONAL BUREAU OF ECONOMIC RESEARCH
1050 Massachusetts Avenue
Cambridge, MA 02138
August 2010

Lilia Maliar and Serguei Maliar acknowledge support from the Hoover Institution at Stanford University,
the Stanford Institute for Theoretical Economics, the Center for Financial Studies in Frankfurt, the
Paris School of Economics, the Ivie, the Ministerio de Ciencia e Innovación and FEDER funds under
the project SEJ-2007-62656 and the Generalitat Valenciana under the grants BEST/2010/142 and BEST/2010/141,
respectively. We thank Wouter Den Haan, Michel Juillard, Sébastien Villemot and an anonymous
referee for useful comments. We thank Ben Malin and Paul Pichler for providing us with the Smolyak-polynomial
terms and log-linear solutions, respectively. The views expressed herein are those of the authors and
do not necessarily reflect the views of the National Bureau of Economic Research.
NBER working papers are circulated for discussion and comment purposes. They have not been peerreviewed or been subject to the review by the NBER Board of Directors that accompanies official
NBER publications.
© 2010 by Serguei Maliar, Lilia Maliar, and Kenneth L. Judd. All rights reserved. Short sections of
text, not to exceed two paragraphs, may be quoted without explicit permission provided that full credit,
including © notice, is given to the source.

Solving the Multi-Country Real Business Cycle Model Using Ergodic Set Methods
Serguei Maliar, Lilia Maliar, and Kenneth L. Judd
NBER Working Paper No. 16304
August 2010
JEL No. C63,C68
ABSTRACT
We use the stochastic simulation algorithm, described in Judd, Maliar and Maliar (2009), and the cluster-grid
algorithm, developed in Judd, Maliar and Maliar (2010a), to solve a collection of multi-country real
business cycle models. The following ingredients help us reduce the cost in high-dimensional problems:
an endogenous grid enclosing the ergodic set, linear approximation methods, fixed-point iteration
and efficient integration methods, such as non-product monomial rules and Monte Carlo integration
combined with regression. We show that high accuracy in intratemporal choice is crucial for the overall
accuracy of solutions and offer two approaches, precomputation and iteration-on-allocation, that can
solve for intratemporal choice both accurately and quickly. We also implement a hybrid solution algorithm
that combines the perturbation and accurate intratemporal-choice methods.
Serguei Maliar
Department of Economics
University of Alicante
Campus San Vicente del Raspeig
Ap. Correos 99, 03080 Alicante, Spain
maliars@merlin.fae.ua.es
Lilia Maliar
Department of Economics
University of Alicante
Campus San Vicente del Raspeig
Ap. Correos 99, 03080 Alicante, Spain
maliarl@merlin.fae.ua.es

Kenneth L. Judd
Hoover Institution
Stanford University
Stanford, CA 94305-6010
and NBER
kennethjudd@mac.com

1

Introduction

In the present paper, we show how to apply two ergodic-set algorithms for
solving a collection of multi-country real business cycle models proposed
by Den Haan, Judd and Juillard (2010) (henceforth, DJJ). One of these
algorithms is the stochastic simulation algorithm (SSA) described in Judd,
Maliar and Maliar (2009, 2010b).12 The other is the projection cluster-grid
algorithm (CGA) developed in Judd, Maliar and Maliar (2010a) (henceforth,
JMM). The models studied in the current JEDC project include up to 10
countries (i.e., 20 state variables) and feature heterogeneity in fundamentals
(preferences and technology) and endogenous labor-leisure choice, as well as
complete markets, adjustment costs, continuously valued state variables, and
non-additively separable preferences and technology.
SSA and CGA build on strategies that allow to reduce the cost of finding
global solutions in high-dimensional applications. The first and most important distinctive feature of these two methods is that they operate on endogenous domains which enclose the ergodic set: SSA computes a solution on a
set of simulated points, whereas CGA does so on a grid of points constructed
by clustering simulated data (the center of each cluster represents one grid
point). Focusing on the ergodic set allows us to avoid the costs associated
with computing solutions in those areas of the state space that are never visited in equilibrium. Second, to approximate policy functions, SSA and CGA
use polynomials with additively separable terms, estimate the polynomial coeﬃcients using numerically stable linear approximation methods and update
the coeﬃcients along iterations using a fixed-point iteration method. These
choices ensure that the cost of approximating the policy functions does not
increase significantly with the dimensionality of the problem (in particular,
because we iterate on policy functions of all countries simultaneously rather
than country by country). Finally, to evaluate conditional expectations, SSA
and CGA rely on integration methods that are particularly suitable for high1

JMM (2009) present SSA in the context of a one-country model. In a more recent
version of the paper, JMM (2010b) extend the results to include the case of a multi-country
model similar to Model 1 of the current JEDC project.
2
SSA is similar to the simulation-based parameterized expectations algorithm (PEA)
by Marcet (1988) and Den Haan and Marcet (1990) in how it uses stochastic simulation
to compute an ergodic distribution, its support and the associated policy functions. SSA
diﬀers from the simulation-based PEA in that it relies on a mixture of techniques that
ensures numerical stability; see JMM (2009) for a discussion.

2

dimensional applications. Namely, SSA combines Monte Carlo integration
and regression in a manner that makes it possible to approximate expectations (integrals) in all simulated points at once, whereas CGA performs
numerical integration using low-cost non-product monomial rules and the
product Gauss-Hermite rule with small numbers of nodes in each dimension
(including the rule with one node).
The models considered in JMM (2010a, 2010b) include up to 200 countries and thus, are more challenging in the dimensional aspect than those
studied in the JEDC project. However, the models of the JEDC project are
more challenging in another aspect, namely, in that solving for consumption
and labor of heterogeneous countries is a non-trivial task. Let us separate
the intertemporal choice (capital) and intratemporal choice (consumption
and labor). The intertemporal choice is concerned with dynamics and is
characterized by the capital policy functions defined in terms of state variables. Such functions are also the laws of motion for capital and allow to
compute an entire capital path without solving for consumption and labor.
The intratemporal-choice problem is static: Given a capital path, in each
period of time, we must solve a system of static optimality conditions (including a resource constraint) with respect to consumption and labor. In
the models of the JEDC project, this system cannot be solved analytically.
Solving this system numerically a large number of times (in each time period, iteration, grid point, integration node) is costly, especially when the
number of countries is large. Moreover, as we show in the present paper,
the intratemporal choice must be computed with a high degree of accuracy;
otherwise, the overall accuracy of solutions decreases.
In the present paper, we describe two novel intratemporal-choice approaches that can find the consumption and labor allocations both accurately and quickly. Our first approach, called iteration-on-allocation, relies
on a numerical solver that implements fixed-point iteration directly on the
intratemporal-choice variables. (The policy functions for the intratemporalchoice variables are never constructed explicitly). This approach allows us
to achieve eﬀectively zero errors in all intratemporal-choice conditions (including the resource constraint) so that the only source of errors for us is
Euler-equation errors.3 The iteration-on-allocation solver does not require
derivatives (Jacobian and Hessian), and its cost does not increase signifi3

This approach was originally proposed in the context of PEA in Maliar and Maliar
(2004) and was later implemented for SSA and CGA.

3

cantly with dimension. Moreover, it can work with vectors and matrices,
making it fast in vectorized applications.
Our second approach, called precomputation, constructs the intratemporalchoice functions on an appropriately chosen grid of points outside the main
iterative cycle and uses the precomputed functions to interpolate the intratemporal choice inside the main iterative cycle as if a closed-form solution
was available.4 Like iteration-on-allocation, this approach can work with
vectors and matrices and attains high accuracy in the examples considered.
The iteration-on-allocation and precomputation approaches can be vectorized because of the separation of the intertemporal and intratemporal
choices. Given the laws of motion for capital, we construct a capital path
without solving for the intratemporal-choice variables (consumption and labor). Then, given a capital path, we compute all the consumption and labor
allocations at once rather than one by one.
The accuracy and speed of the SSA and CGA methods under our baseline implementation are assessed in Kollmann, Maliar, Malin and Pichler
(2010) (henceforth, KMMP). In the present paper, we report a few additional
experiments that show how the performance of the CGA method depends
on the specific integration method, approximating polynomial function and
intratemporal-choice approach.
First, we find that CGA can compute solutions of essentially the same
accuracy as those submitted for the comparison in KMMP (2010) but at a
significantly lower cost. Our baseline integration method (used to compute
solutions submitted to the comparison in KMMP, 2010) is an accurate but
expensive two-step procedure that combines a cheap non-product monomial
rule and an expensive product Gauss-Hermite rule. It turns out that such a
high-accuracy integration method is not needed for the models of the JEDC
project since cheaper and less accurate integration methods also produce accurate solutions. For example, it took us 35 hours to solve an asymmetric
ten-country model using our two-step integration procedure (see Table 3 in
KMMP, 2010). In the present paper, we solve the same model in 7 minutes
using only the first step of our two-step integration procedure without a visible accuracy loss (solution errors are identical up to the fourth digit). Moreover, using the one-node Gauss-Hermite rule advocated in JMM (2010a), we
4

Maliar and Maliar (2005) introduce the precomputation approach in the context of the
standard neoclassical growth model for computing labor-leisure choice outside the main
iterative cycle. Maliar and Maliar (2007) implement this approach in the context of the
current JEDC project.

4

solve this model in 2 minutes with a modest accuracy loss (maximum error
increases by 5%).
Second, we find that the third-degree polynomial delivers solutions that
are almost an order of magnitude more accurate than those produced by
our baseline second-degree polynomial (used to generate the results for the
comparison in KMMP, 2010). We also find that the Smolyak polynomial,
used in the Smolyak collocation algorithm by Malin, Krueger and Kubler
(2010) (henceforth, MKK), allows CGA to achieve nearly the same accuracy
as does the third-degree polynomial. However, under the Smolyak polynomial, the cost grows less rapidly with dimension than under the third-degree
polynomial (independently of dimension, the Smolyak polynomial has only
four times more terms than the second-degree polynomial).
Third, our approach in which consumption and labor are approximated
by functions of both the current-period state variables and the current period
capital choices (i.e., next period’s values of the endogenous state variables)
delivers much better accuracy than the standard intratemporal-choice approach that approximates policy functions for consumption and labor by
functions of state variables only. To be more specific, we approximate the
consumption policy function(s) by a polynomial of the same (second) degree
as that used to approximate the capital policy functions, and we obtain substantially larger approximation errors in the intratemporal-choice conditions
than in the intertemporal-choice conditions (Euler equations).5 For comparison, we also solve the same model using the precomputation approach.
Neither our baseline iteration-on-allocation approach (used to compute the
solutions reported in KMMP, 2010) nor our precomputation approach (implemented in the present paper) restrict the overall accuracy of solutions.
Finally, we propose a way to increase the accuracy of the solution methods
that do not accurately compute the intratemporal choice in their own solution
procedures. We specifically take the capital policy functions delivered by such
a method and replace its low-accuracy solution for consumption and labor
with a high-accuracy solution (computed by the iteration-on-allocation and
precomputation approaches). In our examples, this replacement increases
the overall accuracy of solutions by an order of magnitude. We apply this
idea for constructing a hybrid solution algorithm that combines the perturbation method (a cheap way to compute capital policy functions) and our
5

The importance of accuracy in intratemporal choice for the overall accuracy of solutions is also seen from Table 6 of the comparison paper by KMMP (2010).

5

intratemporal-choice methods (a cheap way to accurately compute consumption and labor allocations).
The rest of the paper is as follows: Section 2 presents the model and
derives the first-order conditions. Section 3 describes how SSA and CGA
address challenges of high-dimensional problems. Section 4 develops two approaches for computing the intratemporal choice. Section 5 outlines the steps
of SSA and CGA. Section 6 describes the baseline and alternative implementations of SSA and CGA. Section 7 presents the numerical results for CGA
and constructs a hybrid of the perturbation and accurate intratemporalchoice methods. Finally, Section 8 concludes.

2

The model

We consider a model with a finite number of countries, N, in which each country is populated by a representative consumer. A social planner maximizes a
weighted sum of the expected lifetime utilities of the countries’ representative
consumers subject to the aggregate resource constraint, i.e.,
Ã∞
!
N
X
X
¡
¢
j
j
E0
τj
β t uj ct , t
(1)
max
j=1,...,N
j j j
{ct , t ,kt+1 }t=0,...,∞ j=1
t=0
subject to

N
X
j=1

cjt =

N
X

⎡

¡
¢
⎣ajt f j ktj , jt − φ ktj
2
j=1

Ã

j
kt+1
ktj

!2

−1

⎤

j ⎦
,
+ ktj − kt+1

(2)

where Et is the operator of conditional expectation; cjt , jt , ktj , ajt , uj , f j and
τ j are consumption, labor, capital, productivity level, utility function, production function and welfare weight of a country j ∈ {1, ..., N}, respectively;
β is the discount factor; and φ is the adjustment-cost
parameter.
¡ 1
¡ 1 Initial
¢
¢ conN
N
dition (k0 , a0 ) is given, where k0 ≡ k0 , ..., k0 and a0 ≡ a0 , ..., a0 . The
process for productivity levels in country j is given by
ln ajt = ρ ln ajt−1 + σεjt ,

(3)

where εjt ≡ et + ejt with et and ejt being common and country-specific productivity shocks, respectively, et , ejt ∼ N (0, 1); ρ is the autocorrelation coefficient of the productivity level; and σ determines the standard deviation of
the productivity level.
6

An interior solution to the social planner’s problem (1) − (3) satisfies
first-order conditions (FOCs) of the form
³ 0 0´ 0
¡ j j¢ j
j
j0
(4)
uc ct , t τ = uc cjt , jt τ j ,
¡
¢
¡
¢
¡
¢
uj cjt , jt = −ujc cjt , jt ajt f j ktj , jt ,
¡
¢
© ¡
¢£
¡ j
,
ujc cjt , jt ωjt = βEt ujc cjt+1 , jt+1 π jt+1 + ajt+1 fkj kt+1

where j, j 0 ∈ {1, ..., N}, and ω jt and π jt are defined as
Ã
!
j
kt+1
j
−1 ,
ωt ≡ 1 + φ
ktj
π jt

φ
≡1+
2

Ã

(5)

j
t+1

¢¤ª

,

(6)

!Ã
!
j
j
kt+1
kt+1
−1
+1 .
ktj
ktj

Here, and further on, notation of type Fxm stands for the first-order partial
derivative of a function F (..., xm , ...) with respect to a variable xm .
In the project, eight models are considered. Models 1, 2, 3 and 4 have
the same types of preferences and technology as do Models 5, 6, 7 and 8,
respectively, however, the former models assume identical preferences and
technology parameters for all countries, while the latter models have diﬀerent
parameters across countries. Models 1 and 5 do not have endogenous laborleisure choice, while the other models do. A description of the models studied
is provided in Juillard and Villemot (2010).
Intertemporal versus intratemporal choices Let us make a distinction
between intertemporal and intratemporal choices. Consider a capital policy
j
function that determines a country’s j end-of-period capital stock, kt+1
, as a
function of the current state variables, kt and at ,
j
kt+1
= K j (kt , at ) ,
(7)
¡
¡
¢
¢
j
where kt ≡ kt1 , ..., ktN and at ≡ a1t , ..., aN
t . We call kt+1 an intertemporalchoice variable because it captures dynamic aspects of the planner’s choice.
A capital policy function is an equilibrium law of motion for capital.
For each period t, given kt , at and kt+1 , we must solve a system of 2N static optimality conditions (i.e., one resource constraint (2), N−1 conditions (4)

7

¡
¡
¢
¢
and N conditions (5)) with respect to ct ≡ c1t , ..., cN
and `t ≡ 1t , ..., N
t
t .
A solution to this system is given by solution manifolds for consumption and
labor:
cjt = Φj (kt , at , kt+1 )

and

j
t

= Θj (kt , at , kt+1 ) ,

j = 1, ..., N.

(8)

We refer to consumption ct and labor `t as intratemporal-choice variables
because under our representation, such variables are determined within period t if the state, (kt , at ), and the intertemporal choice, kt+1 , are given. For
Model 1, the intratemporal choice can be expressed analytically, while for
Models 2-8, it must be approximated numerically.

3

Addressing challenges of high dimensions

The high-dimensional models described in DJJ (2010) pose four challenges
for numerical methods designed to find a global solution: (i) a large size of
the domain on which the solution is computed, (ii) a high cost of finding the
polynomial coeﬃcients in the approximating polynomial functions, (iii) a
large number of integration nodes for evaluating the conditional expectation
functions, and (iv) a high cost of solving for the intratemporal choice.
JMM (2010a, 2010b) show how to address the first three challenges in the
context of CGA and SSA, respectively. The problems solved in JMM (2010a,
2010b) are of higher dimensionality (they include up to 200 countries) but
simpler in the structure of the intratemporal choice (which can be characterized analytically) than those studied in the current JEDC project. The
strategies used by JMM (2010a, 2010b) to address challenges (i), (ii) and (iii)
are discussed in Sections 3.1, 3.2 and 3.3, respectively, and the coordination
of these strategies is described in Section 3.4. The last challenge, (iv), which
is concerned with the intratemporal choice in high-dimensional problems, is
not studied in JMM (2010a, 2010b). In the present paper, solving for the
intratemporal choice accurately proved to be crucial for the overall accuracy
of solutions. We address the intratemporal-choice challenge separately, in
Section 4.

3.1

Multi-dimensional domain

To make a numerical method suitable for high-dimensional applications, we
must restrict attention to a relatively small set of grid points in the multi8

dimensional space.6 Both SSA and CGA achieve this goal by focusing on
the ergodic set of points realized in equilibrium. In Figure 1a, we show
the ergodic set constructed from a simulated series of 10, 000 observations,
which are produced by the standard representative-agent neoclassical stochastic growth model. SSA computes the solution on the given set of simulated points (the number of simulated points is controlled by the researcher
and needs not necessarily increase with the number of countries, N). CGA
chooses a more eﬃcient representation of the ergodic set; namely, it replaces
a large number of closely situated simulated points with relatively few representative points constructed by grouping similar points into clusters (the
number of representative points is again controlled by the researcher). To
be specific, CGA transforms correlated variables into uncorrelated principal
components (denoted P Ct1 and P Ct2 ) using principal components (PCs) decomposition (see Figure 1b); normalizes the principal components to zero
mean and unit variance (see Figure 1c); and constructs I clusters applying
a clustering algorithm. It subsequently uses the centers of the constructed
clusters as a grid for projections; see JMM (2010a) for details. (Note that
CGA does not compute diﬀerent solutions in each cluster, but a global solution on the entire cluster grid). Making the domain endogenous to the
model allows SSA and CGA to compute a solution only in the relevant area
of the state space (an ellipsoid area shown in Figure 1a). This eliminates an
enormously large number of grid points that are never visited in equilibrium.
For example, for a model with 100 state variables, a hypersphere is only
about a 2 · 10−70 fraction of a multi-dimensional hypercube which encloses
the hypersphere; see JMM (2010a) for a further discussion.

3.2

Multi-dimensional polynomials

SSA and CGA parameterize policy functions by an additively separable complete polynomial. For example, parameterizing the end-of-period capital
stock of a country j by a first-degree polynomial yields
j
j N
j
j
kt+1
= v0j + v1j kt1 + ... + vN
kt + vN+1
a1t + ... + v2N
aN
t ,

(9)

6
The literature commonly considers a multi-dimensional hypercube domain composed
of the tensor product of discretized state variables. In this case, the total number of
grid points grows exponentially with the dimensionality of the state space (the curse of
dimensionality).

9

¡
j
j
j ¢0
where v0j , v1j , ..., vN
, vN+1
, ..., v2N
≡ vj ∈ R(2N +1)×1 is country’s j vector of
the polynomial coeﬃcients. The number of polynomial terms in the first-,
second- and third-degree complete polynomials grows with the dimensionality
of the problem linearly, quadratically and cubically, respectively; see Table 1
in JMM (2010a). When the dimensionality is large, high-degree polynomials
are costly.
The assumption of additively separable polynomials allows us to estimate
the polynomial coeﬃcients using fast and numerically stable linear approximation methods, such as the least-squares methods using SVD and QR
factorization, Tikhonov regularization, least-absolute deviation methods and
the principal components method; see JMM (2009). Moreover, it allows us to
estimate the polynomial coeﬃcients for all N countries at once rather than
country by country.
To update the polynomial coeﬃcients along iterations, SSA and CGA use
fixed-point iteration, which is a simple derivative-free iteration method whose
cost does not significantly increase with the dimensionality of the problem;
see Judd (1998, p. 555-557).7 Fixed-point iteration computes the coeﬃcients
for the next iteration as a weighted average of the coeﬃcients at the beginning
and at the end of the previous iteration. It works for vectors and matrices
and allows to iterate on policy functions of all countries simultaneously. A
shortcoming of fixed-point iteration is that it does not guarantee convergence.
However, a slow updating is typically suﬃcient to ensure convergence; see
Section 4.2 for a discussion. In the models of the JEDC project, fixed-point
iteration was always numerically stable.

3.3

Multi-dimensional integration

SSA and CGA require the calculation of integrals that represent conditional
expectation functions in the Euler equations. SSA employs Monte Carlo
integration combined with regression, as is used in Den Haan and Marcet
(1990). This integration procedure makes it possible to infer expectations
(to compute integrals) simultaneously in all simulated points. If the length
7

Fixed-point iteration is simpler to implement than alternative iterative schemes such as
time iteration (that involves finding a solution to a system non-linear equation; see Judd,
1998, p. 553-555) or Newton methods (that require to compute Jacobian and Hessian
matrices and to use optimization methods; see Judd, 1998, p. 103-119). Also, Gaspar
and Judd (1997) argue that fixed-point iteration has a lower computational cost than time
iteration and Newton methods for problems of medium and high dimensionality.

10

of simulations T is held fixed, the cost of this integration procedure does not
grow substantially with the dimensionality of the problem (though accuracy
may decrease as more polynomial coeﬃcients must be identified); see JMM
(2010b) for the corresponding results. In particular, JMM (2010b) find that
under T = 10, 000, first- and second-degree complete polynomials are feasible
for a model (similar to Model 1 of the present project) with up to N = 200
and up to N = 30 countries, respectively.
CGA is a projection method and relies on deterministic methods of integration. The choice of an integration method depends on the dimensionality of the problem. One-dimensional integrals can be computed accurately using the Gaussian quadrature approach (as is done, for example,
in Judd’s (1992) Galerkin algorithm). For a given weighting function w (ε),
Gaussian quadrature approximates an integral (conditional expectation) by
H
X
R
E [G (ε) w (ε)] = R G (ε) w (ε) dε ≈
wh G (εh ) for some nodes {εh }h=1,...,H
h=1

and weights {wh }h=1,...,H . One can extend the Gaussian quadrature approach
to multi-dimensional integration problems using a product rule. However,
product rules are not feasible in high-dimensional problems due to the curse
of dimensionality: the total number of integration nodes H N increases exponentially with dimension. To reduce the cost of numerical integration
in economic applications of high dimensionality, Judd (1998) proposes to
use non-product monomial integration formulas; see Judd (1998, p.271 and
p.331). A large collection of such formulas is available in Stroud (1971).
JMM (2010a) elaborate the monomial formulas for a heterogeneous-agent
model similar to those studied in the present paper, illustrate the use of such
formulas by way of examples and provide an exhaustive comparison of the
performance of the CGA method under diﬀerent integration strategies. Such
strategies include the product Gauss-Hermite rule with 1, 2 and 3 nodes
in each dimension (referred to as Q (1), Q (2) and Q (3), respectively) and
non-product monomial rules with 2N and 2N 2 + 1 nodes (referred to as M1
and M2, respectively). Using second-degree polynomials, JMM (2010a) find
that the integration formulas Q (3), Q (2), M2, M1 and Q (1) are feasible
for the models with up to N = 6, N = 8, N = 12, N = 20 and N = 40
countries, respectively. Using first-degree polynomials, JMM (2010a) find
that the formulas M1 and Q (1) are feasible for the models with up to N =
100 and N = 200 countries, respectively.

11

3.4

Coordinating the approximation, integration and
intratemporal-choice strategies

As is argued in JMM (2010a), making a numerical method cost-eﬃcient requires proper coordination between the approximation and integration strategies. For example, if a polynomial approximation of a given degree can deliver
accuracy of no more than 10−4 , it would be ineﬃcient to compute integrals
with accuracy of 10−10 (doing so would increase costs without increasing
the overall accuracy of the solutions). It is therefore important to identify
combinations of the approximation and integration strategies that are well
matched in terms of accuracy.
JMM (2010a) identifies the following regularities: For a first-degree polynomial, all integration methods lead to the same level of accuracy, including
the one-node Gauss-Hermite quadrature rule. For a second-degree polynomial, the two- and three-node Gauss-Hermite rule and the monomial formulas
lead to the same level of accuracy (up to the fourth digit), while the one-node
Gauss-Hermite rule leads to Euler-equation errors that are 5 − 10% larger
than those calculated with more accurate integration methods. JMM (2010a)
give an example of coordination between the approximation and integration
strategies that consists in combining the second-degree polynomial and the
one-node Gauss-Hermite integration rule. This combination makes it possible to increase the number of countries, N, from 20 to 40 at a cost of a small
decrease in accuracy.
In the presence of endogenous labor-leisure choice, the approximation
and integration strategies should be properly coordinated not only with each
other, but also with the intratemporal-choice strategy. The numerical results
in Section 7.1 show that insuﬃcient accuracy in intratemporal choice can
drastically reduce the overall accuracy of the solutions; the importance of
accuracy in intratemporal choice is also seen in Table 6 of the comparison
paper by KMMP (2010).

4

Intratemporal choice

In Section 4.1, we discuss intratemporal-choice approaches that currently
exist in the literature. In Sections 4.2 and 4.3, we describe two novel approaches, iteration-on-allocation and precomputation, that allow us to solve
for the intratemporal choice both accurately and quickly. Finally, in Section
12

4.4, we show that combining iteration-on-allocation and precomputation can
produce additional gains in speed.

4.1

Standard intratemporal-choice approaches

Existing literature provides two approaches to computing the intratemporal
choice. First, given kt , at and kt+1 , one can solve a system of 2N equations,
(2), (4) and (5), with respect to 2N unknowns, ct and `t , using a standard
Newton method. The cost of this approach can be prohibitive because we
must find a numerical solution to the 2N-dimensional system of equations
a large number of times (in each time period, grid point, integration node)
within an iterative cycle.
Second, one can treat the intratemporal choice in the same way as the
intertemporal choice, i.e., one can compute the policy functions for the
intratemporal-choice variables, cjt = C j (kt , at ) and jt = Lj (kt , at ) satisfying the corresponding optimality conditions (2), (4) and (5) inside the
main iterative cycle. (In contrast to the intratemporal-choice manifolds
Φj (kt , at , kt+1 ) and Θj (kt , at , kt+1 ) in (8) defined for any kt+1 , the policy functions C j (kt , at ) and Lj (kt , at ) do not include kt+1 as an argument
because such functions are defined for the equilibrium intertemporal choice,
kt+1 , determined by the capital policy functions (7)). In our experiments,
this approach does not produce suﬃciently accurate results; see Section 7.1.
Moreover, simultaneous iterations on policy functions for the intertemporaland intratemporal-choice variables reduce both the numerical stability and
the speed of convergence.

4.2

Iteration-on-allocation

The first intratemporal-choice approach we use relies on a numerical solver,
(fixed-point) iteration-on-allocation, proposed by Maliar and Maliar (2004).
This method’s name emphasizes that fixed-point iteration is applied to the
intratemporal-choice allocations and distinguishes it from a diﬀerent fixedpoint iteration procedure, described in Section 5, that is applied to the coefficients of an approximating polynomial function.
The iteration-on-allocation approach proceeds as follows:
• Step 1. Re-write conditions (2), (4) and (5) to define a mapping g that
explicitly and uniquely maps a set of values z t = (ct , `t ) into a new set
13

´
³
et = e
of values z
ct , èt (this is possible to do for all of the eight models
studied in the current JEDC project):
et = g (z t ) .
z

(10)

et via mapping (10).
• Step 2. Use some initial guess on z t and calculate z

• Step 3. Use partial updating (damping) to compute an input for the
z t , where ς ∈ (0, 1) is a damping paranext iteration as (1 − ς) z t + ςe
meter.
Iterate until a fixed point, z t = g (z t ), is found with a given degree
of accuracy, i.e.,
°
T °
°
e
z
1 X°
−
z
t
t
°
° < 10−θ ,
(11)
°
ς · T t=1
zt °

where θ > 0, and k·k is some vector norm.

On the initial iteration, we can assume that z t is equal to its steady-state
value. Typically, we need not iterate on all 2N unknown elements of ct and `t
since there are explicit closed-form expressions relating these variables, and
fixing one or a few of them allows to analytically find the values of all the
intratemporal-choice variables. As an example, we describe how to construct
a mapping of type (10) for Model 5; the mappings for Models 6-8 are given
in Appendix A.
Example 1 (Model 5). There is no labor-leisure choice, so condition (5) is
absent. The remaining intratemporal-choice conditions (4) and (2), written
in a form suitable for iteration-on-allocation, respectively, are

N
X

⎡

e
cjt =

i−γ j
h¡ ¢
−1/γ 1 1
c1t
τ /τ j
,

¡ ¢
⎣ktj + ajt A ktj α − φ ktj
e
c1t =
2
j=1
j=1,...,N

Ã

j = 2, ..., N,

⎤
!2
N
j
X
kt+1
j ⎦
− kt+1 −
e
cjt ,
j −1
kt
j=2

(12)

(13)

where {γ j }
are the utility-function parameters, and A is a normalizing
constant. For given kt , at and kt+1 , equations (12) and (13) define a mapping
14

e
c1t = g (c1t ). We iterate on consumption of the first country, c1t , as follows:
© j ªj=2,...,N
ct
from (12); obtain e
c1t from
Assume some value for c1t ; compute e
(13); if c1t 6= e
c1t , compute the input for the next iteration as (1 − ς) c1t + ςe
c1t .
Iterate until convergence.
Iteration-on-allocation has two advantages over standard Newton-type
methods. First, iteration-on-allocation does not require to compute derivatives (such as Jacobian or Hessian) but instead performs a straightforward
summation; as a result, its cost does not increase considerably with the dimensionality of the problem. Second, iteration-on-allocation can operate on
a time series or on all grid points simultaneously while Newton-type methods
compute a solution point by point and are more diﬃcult to vectorize.
Convergence of fixed-point iteration is in general not guaranteed; for formal results about convergence of fixed-point iteration, see Judd (1998 p.165166). However, damping can often help achieve convergence. In particular,
by choosing an appropriate value of the damping parameter, ς, we were able
to achieve convergence in all eight models of the current JEDC project. Below, we discuss the issue of convergence using Model 5 as an example.
Example 2 (Model 5). Conditions (12) and (13) together imply
c1t

¸−γ j
N ∙ 1
X
¡ 1¢
τ ¡ 1 ¢−1/γ 1
= g ct ≡ ct −
,
c
τj t
j=2

(14)
j=1,...,N

are
where ct is aggregate consumption that is given. Note that if {γ j }
0 1
1 ∗
of the same sign,
g (ct ) < 0. There is a unique fixed point (ct ) satis¡ then
∗
∗¢
fying (c1t ) = g (c1t ) (at this point, g (c1t ) crosses the 45o line). However,
applying g iteratively to some initial guess c1t , i.e., g (...g (g (c1t ))) does not
guarantee the convergence to this fixed point. Depending on whether g0 is
larger than, smaller than or equal to minus one, the result will be convergence, divergence or cycling, respectively. (Note that the slope of g depends
on the model’s parameters and welfare weights, as well as on the specific way
in which g is constructed). Figures 2a and 2b show, respectively, the cases
of convergence and divergence of fixed-point iteration. Figures 2c and 2d illustrate fixed-point iteration with damping (1 − ς) c1t + ςg (c1t ). In particular,
Figure 2d demonstrates that a suﬃciently small damping parameter ς can
help restore convergence.
15

4.3

Precomputation

The second intratemporal-choice approach we use is precomputation, which
consists of constructing intratemporal-choice manifolds defined in (8) outside the main iterative cycle using either analytical derivations or numerical
computations or a combination of both. This approach was originally proposed by Maliar and Maliar (2005) for constructing a labor manifold outside
the main iterative cycle in the standard neoclassical growth model. Maliar
and Maliar (2007) introduced the precomputation approach in the context
of the current JEDC project. In the present paper, we give a more elaborate
description of the precomputation approach.
A general version of the precomputation approach, applied to the model
(1) − (3), constructs the intratemporal-choice manifolds Φj (kt , at , kt+1 ) and
Θj (kt , at , kt+1 ) in (8) as follows:
• Step 1. Outside the
cycle, choose a grid of P values for
© main iterative
ª
0
kt , at , kt+1 , i.e., kp , ap , kp p=1,...,P . For each grid point p = 1, ...P ,
solve equations (2), (4) and (5) using a numerical solver with respect
to consumption cjp and labor jp for j = 1, ..., N .
• Step 2. Extend the constructed set functions to the relevant continuous
domain using some interpolation method (a global polynomial approximation, piecewise linear polynomial approximation, splines, etc.), such
that
b j (k, a, k0 )
cj = Φ

and

j

b j (k, a, k0 ) ,
=Θ

j = 1, ..., N,

(15)

b j are the precomputed consumption and labor manifolds
b j and Θ
where Φ
of a country j, and (k, a, k0 ) ∈ R3N .

• Step 3. In the main iterative cycle, use the precomputed manifolds
b j (k, a, k0 ) to find the intratemporal choice given the
b j (k, a, k0 ) and Θ
Φ
state, (kt , at ), and the intertemporal choice, kt+1 .
Many applications have enough structure to simplify the precomputation
approach in two ways. First, it might be not necessary to precompute all
the intratemporal-choice manifolds because some of these manifolds can be
constructed analytically. Second, it may be possible to precompute the intratemporal choice in terms of a set of arguments that is smaller than kt , at ,
16

kt+1 or that is given by some function of kt , at , kt+1 . We illustrate these two
points by way of example for Model 5 described in Maliar and Maliar (2007).
In this case, we precompute a single manifold, consumption of country 1, c1t ,
in terms of one argument, aggregate consumption, ct (which is a function of
kt , at , kt+1 ).
Example 3 (Model 5). Outside the main iterative cycle, take P values
for aggregate consumption ct , i.e., {cp }p=1,...,P . For each cp , use a numerical
solver to find a solution c1p to equation (14) written as
c1p

¸−γ j
N ∙ 1
X
τ ¡ 1 ¢−1/γ 1
+
= cp .
c
τj p
j=2

(16)

Interpolate the constructed set function to a continuous domain to obtain the
manifold b
c1 (c). Inside the main iterative cycle, given kt , at , kt+1 , compute
ct from resource constraint (2), use the precomputed manifold to find consumption of country 1, c1t = b
c1 (ct ) and compute consumption of the other
i
h 1
−γ j
−1/γ 1
countries as cjt = ττ j (c1t )
, j = 2, ..., N.

As with Model 5, precomputing a single intratemporal-choice manifold
(either consumption or labor manifolds) is suﬃcient for Models 2 and 6; see
the formulas in Appendix A. For Models 3, 4, 7 and 8, we can precompute
N labor manifolds and find the corresponding consumption allocations using
the formulas provided in Appendix A; note that for these models, we cannot
precompute N consumption manifolds and find the corresponding labor allocations analytically: there is a closed-form expression for consumption given
labor but there is no closed-form expression for labor given consumption.8
We can precompute the intratemporal choice in Model 2 in terms of two
composite arguments (see Appendix B for details). For the remaining models - Models 3, 4, 6, 7 and 8 - the intratemporal-choice manifolds must be
precomputed in terms of 3N arguments kt , at , kt+1 . To make the precomputation approach feasible for high-dimensional problems, we can precompute
the intratemporal-choice manifolds on the ergodic set realized in equilib8

The advantage of solving for labor over solving for consumption was exploited by
Maliar and Maliar (2005) to simplify finding the intratemporal choice in the standard
neoclassical growth model.

17

rium.9 For SSA, the domain for precomputation is a set of simulated points;
for CGA, it is a set of the clusters’ centers obtained from simulated points.
The domains of SSA and CGA are discussed in Section 5.

4.4

Combining iteration-on-allocation and precomputation

For Models 3, 4, 7 and 8, the pure iteration-on-allocation approach requires
© ªj=1,...,N
to iterate simultaneously on labor allocations of N countries jt
(see
Appendix A). In turn, the pure precomputation approach requires to precompute the labor choice of each country as a function of 3N arguments kt ,
at , kt+1 . We now show that under the assumption of additively separable
production across countries, we can combine iteration-on-allocation and precomputation into a single method that precomputes the labor manifolds in
terms of three arguments and iterates on one allocation.10 This is possible
because conditions (4) and (5) implicitly define the intratemporal choice of
each country j in terms of its own capital¡ktj , its own
productivity
level a¢jt
¢
¡
and aggregate consumption ct ; i.e., cjt = Ωj ktj , ajt , ct and jt = Λj ktj , ajt , ct ,
j = 1, ..., N. Model 2 is an example of the economy in which such manifolds
can be constructed analytically (see Appendix B); generally, however, such
manifolds must be precomputed numerically.11
We combine iteration-on-allocation and precomputation as follows:
• Step 1. Outside the main iterative cycle,
for ª
each country j, choose
©
a grid of P values for ktj , ajt , ct , i.e., kpj , ajp , cp p=1,...,P . For each grid
point p = 1, ...P , solve equations (4) and (5) using a numerical solver
with respect to cjp and jp for j = 1, ..., N.
9

To construct the domain for the intratemporal-choice manifolds, one can use a tensorproduct grid of 3N arguments kt , at , kt+1 . However, the number of grid points will grow
exponentially with dimension, and the precomputation method will not be feasible even
for a moderately large number of countries.
10
Combining iteration-on-allocation and precomputation is also possible for Models 2
and 6, but does not provide any advantages over the pure iteration-on-allocation method
described in Section 4.2.
11
Maliar and Maliar (2001, 2003a) construct similar intratemporal-choice manifolds analytically for certain classes of heterogeneous-agent economies and use these manifolds to
derive non-Gorman aggregation results.

18

• Step 2. Interpolate the constructed set functions to the relevant continuous domain,
¢
¢
¡
¡
b j kj , aj , c
b j kj , aj , c , j = 1, ..., N,
cj = Ω
and j = Λ
(17)

b j and Λ
b j are the precomputed consumption and labor manifolds
where Ω
of a country j, and (k j , aj , c) ∈ R3 .

b j (kj , aj , c) for
• Step 3. Substitute the precomputed labor manifolds Λ
j = 1, ..., N into resource constraint (2) to define the mapping of the
form e
ct = g (ct ),
⎡
⎤
Ã
!2
N
j
³
´ φ
X
¡
¢
j ⎦
b j ktj , ajt , ct − ktj kt+1 − 1 + ktj − kt+1
⎣ajt f j ktj , Λ
e
ct =
.
j
2
kt
j=1

(18)
Inside the main iterative cycle, compute aggregate consumption, ct ,
using the iteration-on-allocation approach. For each t, given kt , at ,
kt+1 , assume some value for ct and calculate e
ct from (18); if ct 6= e
ct ,
compute an input for the next iteration equal to (1 − ς) ct + ςe
ct . Iterate
until convergence.

Like the pure iteration-on-allocation and precomputation methods, their
combination allows to solve for the intratemporal allocations (including aggregate consumption, ct ) with a high degree of accuracy.

5

Two ergodic-set algorithms

In this section, we describe two ergodic-set algorithms, SSA and CGA, that
we use to solve the models (1) − (3). Both algorithms find a solution on the
ergodic set. However, they diﬀer in how they use information on the ergodic
set: SSA uses simulated points both as a domain for finding the solution
and as nodes for integration, while CGA uses such points exclusively for
constructing the domain (it performs integration using deterministic methods
unrelated to the estimated density function). For both methods, we re-write
Euler equation (6) in a form suitable for parameterizing the capital policy

19

j
function kt+1
= K j (kt , at ):
(
¡
¢
¡ j
ujc cjt+1 , jt+1 £ j
j
kt+1 = Et β j ¡ j j ¢ j π t+1 + ajt+1 fkj kt+1
,
uc ct , t ω t
¡
¢
' Ψj kt , at ; v j ,

j
t+1

¢¤

j
kt+1

)

(19)

where Ψj (kt , at ; vj ) is a flexible functional form used to parameterize the
capital policy function, and v j is a vector of coeﬃcients.12 See Appendix C
for the specifications of (19) corresponding to Models 5-8. We denote by v
a matrix
of
¡ 1 composed
¢ the vectors of polynomial coeﬃcients of all countries,
j
N
v≡ v , ..., v , ..., v .
We assume that Ψj is given by a complete set of ordinary polynomials, i.e.,
Ψj (kt , at ; vj ) ≡ X t v j , where X t is a row vector composed of t-period monomial terms of the state variables, kt and at . For the
¡ first-degree polynomial
¢
function in the example given in (9), we have X t = 1, kt1 , ..., ktN , a1t , ..., aN
∈
t
¡ j j
j
j
j ¢0
1×(2N+1)
j
(2N+1)×1
, and v = v0 , v1 , ..., vN , vN+1 , ..., v2N ∈ R
.
R
We should emphasize that the end-of-period capital stocks kt+1 are the
only variables we approximate by functions of the state variables, kt and at .
The remaining variables (consumption and labor) are either computed by the
iteration-on-allocation solver or obtained from the precomputed intratemporalchoice manifolds in form (8).
Properly separating the intertemporal and intratemporal choices is crucial for the speed of SSA and CGA. Approximating the policy functions for
capital, as in (19), has an important advantage over approximating the policy functions for other variables such as consumption and leisure. Namely,
the equilibrium capital policy functions are the equilibrium capital laws of
j
motion kt+1
= K j (kt , at ) , j = 1, ..., N. As a result, we can first construct
a path for capital, {kt+1 }t=0,...,T , and subsequently fill in the corresponding
intratemporal allocations {ct , `t }t=1,...,T . The iteration-on-allocation and precomputation methods can work with vectors and even matrices and can thus
find the intratemporal choice in all periods, grid points, integration nodes at
once rather than one by one.
12

This kind of parameterization was used by Den Haan (1990) as a device to implement
the simulation-based parameterized expectations algorithm in a model with more than
one Euler equation.

20

5.1

Stochastic simulation algorithm

SSA simultaneously computes the ergodic distribution of state variables, its
support and the associated policy functions. It proceeds as follows:
Fix the simulations length T and initial condition (k0 , a0 ). Draw and fix
for all simulations a sequence of productivity levels {at }t=1,...,T using equation
(3). If precomputation is used, construct the intratemporal-choice manifolds
of type (8) as described in Section 4.3, and if precomputation is combined
with iteration-on-allocation, do so as described in Section 4.4.
• Step 1. For an iteration s, fix some matrix of coeﬃcients v (s). For each
j
=
country j = 1, ..., N, use the assumed capital policy function kt+1
j
X t v to recursively calculate a sequence of capital stocks {kt+1 }t=0,...,T
corresponding to a given sequence of productivity levels {at }t=0,...,T .
• Step 2. Given {kt , at , kt+1 }t=0,...,T , calculate {ct , `t }t=0,...,T using a vectorized version of either iteration-on-allocation or precomputation or
their combination.
• Step 3. For each country j = 1, ..., N, compute the integrand of (19),
¡ j
j ¢
j
£
¡ j
¢¤ j
,
c
u
t+1
c
ytj ≡ β j ¡ j j ¢t+1j π jt+1 + ajt+1 fkj kt+1
, jt+1 kt+1
(20)
uc ct , t ω t
for t = 0, ..., T − 1.

• Step 4. For each country j = 1, ..., N, run a linear regression of the
constructed variable ytj on a set of explanatory variables X t using the
numerically stable approximation methods described in JMM (2009,
2010b),
ytj = X t v j + jt ,
(21)
where jt is a t-period regression error corresponding to country j. Let
b (s).
the matrix of coeﬃcients estimated on iteration s be called v

• Step 5. Compute the matrix of coeﬃcients for the subsequent iteration
s + 1 using fixed-point iteration:
v (s + 1) = (1 − ξ) v (s) + ξb
v (s) ,
where ξ ∈ (0, 1) is a damping parameter.
21

(22)

Iterate on Steps 1 − 5 until a fixed point is found such that for ϑ > 0:
¯
¯
N
T
j
j
(s) − kt+1
(s + 1) ¯¯
1 X X ¯¯ kt+1
(23)
¯
¯ < 10−ϑ ξ,
j
¯
¯
T · N t=1
kt+1
(s)
j=1

j
j
(s) and kt+1
(s + 1) are the j-th country’s capital stocks obtained
where kt+1
on iterations, s and s + 1, respectively, and |·| denotes the absolute value.

5.2

Cluster-grid algorithm

CGA is a projection method that computes a solution on a grid constructed
from clusters of simulated points. It proceeds as follows: Make an initial guess
j
about the capital policy functions kt+1
= X t v j , j = 1, ..., N. Given initial
condition (k0 , a0 ), draw a sequence of productivity levels {at }t=1,...,T using
(3), and simulate the time series solution {kt+1 }t=0,...,T . Using simulated data,
construct I clusters and compute the centers of the clusters, {ki , ai }i=1,...,I ,
to be used as a grid for projections; see JMM (2010a) for a description of
clustering methods and illustrative examples. In each grid point i = 1, ..., I,
construct a function Γj (ki , ai , ε) that represents the integrand in (19),
³¡ ¢0 ¡ ¢0 ´
h¡ ¢0 ¡ ¢0 ³¡ ¢0 ¡ ¢0 ´i ¡ ¢0
ujc cji , ji
π ji + aji fkj kij , ji
kij ,
Γj (ki , ai , ε) ≡ β j ¡ j j ¢
uc ci , i ω j
(24)
¡ 1
¢
N
where ε ≡ ε , ..., ε is the next-period shock. Furthermore, if precomputation is used, construct the intratemporal-choice manifolds of type (8) as
described in Section 4.3, and if precomputation is combined with iterationon-allocation, do so as described in Section 4.4.
• Step 1. On an iteration s, fix a matrix of coeﬃcients v (s). For each
country j, use the assumed capital policy ¡function
to calculate the endj ¢0
of-period capital stock in all grid points, ki ≡ X i v j for i = 1, ..., I.

• Step 2. Given {ki , ai , k0i }i=1,...,I , calculate {ci , `i }i=1,...,I using a vectorized version of iteration-on-allocation, precomputation or their combination.

• Step 3. For each country j = 1, ..., N, use a numerical integration
method (such as non-product monomial rules or product Gauss-Hermite
22

rule) to approximate
the conditional expectations of equation (24). Call
³ ´0
j
the result b
k , i.e.,
i

³ ´0
£
¤
b
kij ≡ E Γj (ki , ai , ε) ,

(25)
¢
¡
where the expectation is computed with respect to ε ≡ ε1 , ..., εN .
To calculate the next-period intratemporal choice {c0i , `0i }i=1,...,I , for
each integration node, use a vectorized version of either iteration-onallocation or precomputation or their combination as described in Section 4.
• Step 4. For each country
³ ´0 j = 1, ..., N, run a linear regression of the constructed variable b
kj on a set of explanatory variables X i using the
i

numerically stable approximation methods described in JMM (2009,
2010b),
³ ´0
b
(26)
kij = X i v j + ji ,

where ji is an i-grid-poind regression error corresponding to country j.
b (s).
Let the matrix of coeﬃcients estimated on iteration s be called v

• Step 5. Compute the matrix of coeﬃcients for the subsequent iteration
s + 1 using fixed-point iteration (22).
Iterate on Steps 1 − 5 until a fixed point is found, such that for ϑ > 0:
¯ ¡ ¢ ³ ´0 ¯
¯ j 0
bj ¯
I
N
1 X X ¯¯ ki − ki ¯¯
(27)
¯
¯ < 10−ϑ ,
¡ j ¢0
¯
I · N i=1 j=1 ¯
k
i
¯
¯

³ ´0
¡ j ¢0
where ki and b
kij are the end-of-period capital stocks before and after
the iteration, respectively.
After achieving convergence, we should generally re-run CGA using the
obtained policy functions for capital as an initial guess for simulation. Doing so controls for the possibility that the initial guess for the capital policy
functions was far from the true solution, and the simulated series (and consequently, our cluster grid) did not adequately represent the true ergodic
set.
23

6

Implementation details

In Section 6.1, we describe the baseline implementation of SSA and CGA
that was used to generate the results presented in the comparison paper by
KMMP (2010). In Section 6.2, we discuss alternative implementations of
these algorithms that are not included in KMMP (2010). Calibration of the
models’ parameters is provided in Juillard and Villemot (2010).

6.1

Baseline implementation of SSA and CGA

Below, we describe the details of the baseline implementation of our methods,
as well as the solution-output, hardware, software and measures of accuracy
and cost.
Stochastic simulation algorithm SSA computes solutions using the firstdegree ordinary polynomial (9). To start the iterative process, we use an
j
(arbitrary) initial guess: kt+1
= 0.9ktj + 0.1ajt for all j = 1, ...N. Since the
steady-state levels of capital and productivity are normalized to one, the
above guess matches the steady-state level of capital. In terms of the vector
j
of coeﬃcients v j , this guess implies that vjj = 0.9, vN+j
= 0.1, j = 1, ...N,
j
and that the remaining coeﬃcients in v are equal to zero. Initial capital
and productivity level are set at their steady-state values: k0j = 1 and aj0 = 1
for all j = 1, ..., N. The simulation length is T = 10, 000.
To estimate the coeﬃcients in the linear regression (21), we use a leastsquares truncated QR factorization method; see JMM (2009) for a discussion.
We set the damping parameter in (22) to be the largest values of ξ that
lead to convergence: ξ = 0.05 for Models 1 and 5, and ξ = 0.03 for the
remaining models. We target seven digits of accuracy in the simulated data
by fixing ϑ = 7 in convergence criterion (23). To rule out explosive and
implosive behavior on initial iterations, we restrict the simulated series for
capital using moving bounds as described in Maliar and Maliar (2003b); in
most cases, however, the artificial bounds were not necessary as the initial
guess led to a stationary simulated series.
Cluster-grid algorithm CGA computes solutions using a second-degree
ordinary polynomial. To start the iterative process, we use the first-degree
polynomial solution computed by SSA as an initial guess. The SSA solution
was used both to compute an initial guess for the matrix of coeﬃcients v
24

and to construct 500 clusters. The clusters were constructed by applying an
hierarchical clustering algorithm with Ward’s linkage to the principal components of the simulated data; see JMM (2010a) for a description of the
clustering methods and illustrative examples.
To estimate linear regression (26), we again use a least-squares truncated
QR factorization method. We set the damping parameter in (22) at ξ = 0.1
for Models 1 and 5, and ξ = 0.05 for all other models. We use ϑ = 7 for
convergence criterion (27). We solve the model twice: first, we compute the
solution using a cheap non-product monomial rule M1 with 2N nodes, and
then, we recompute it using an expensive product Gauss-Hermite rule Q(2)
with two nodes in each dimension (2N nodes in total); see JMM (2010a) for
a description of these integration methods.
Iteration-on-allocation In the baseline versions of both SSA and CGA,
we solve for the intratemporal choice using the iteration-on-allocation approach. We use the damping parameter ς = 0.01 in all cases except for
Models 1 and 5 under CGA in which case we use ς = 0.05. To start iterations under SSA, we assume that consumption and labor are equal to their
steady-state values. Under CGA, we compute an initial guess for consumption and labor using the solution produced by SSA.
We would like to direct attention to an important aspect of the implementation of iteration-on-allocation. Finding consumption and labor allocations
with a high degree of accuracy on each iteration requires a high computational cost and is in fact of no use, since on the next iteration, we must
re-compute consumption and labor allocations for a diﬀerent matrix of coefficients v. We thus do not target any accuracy criteria in consumption and
labor allocations in each iteration on v, but instead perform 10 subiterations
on mapping (10) as described in Section 4 (except for Models 1 and 5 under
CGA in which we perform 3 subiterations). We store in memory consumption and labor allocations obtained after each round of subiterations and use
these allocations as inputs for the next round of the iteration-on-allocation
process. Thus, as the policy functions for capital (characterized by v) are
refined along the iterations, so do our consumption and labor allocations.
To enhance the numerical stability on initial iterations when the solution
is inaccurate, we impose fixed lower and upper bounds (equal to 50% and
150% of the steady-state level, respectively) on consumption in Model 5 and
on labor in Models 6-8. This technique is similar to the moving bounds

25

used to restrict simulated series for capital under SSA. With the imposition
of bounds, the iteration-on-allocation procedure was numerically stable and
converged to a fixed point at a good pace in all of our experiments. In
convergence criterion (11), we use θ = 7.
Solution-output delivered to the testing bench of Juillard and Villemot (2010) Under the iteration-on-allocation approach, SSA and CGA do
not deliver explicit policy functions for consumption and labor. The only
solution-output they produce is a matrix of the polynomial coeﬃcients for
the capital
policy functions
(laws of motion) of N heterogeneous countries,
¡
¢
v = v 1 , ..., vj , ..., vN . Thus, in addition to the polynomial coeﬃcients v, we
supply to the testing bench of Juillard and Villemot (2010) four iterationon-allocation routines (one per each asymmetric model and its symmetric
counterpart) that allow to find the intratemporal choice in simulation.13
The simulation of our solutions includes two steps: First, the capital laws
j
of motion, kt+1
= Ψj (kt , at ; vj ) , j = 1, ...N, are used to generate the capital
path {kt+1 }t=0,...,T . Then, given {kt , at , kt+1 }t=0,...,T , the corresponding intratemporal choice {ct , `t }t=0,...,T is filled in using the iteration-on-allocation
method described in Section 4.2 and Appendix A. To begin the iteration-onallocation process, we set consumption and labor equal to their steady-state
values; we use the damping parameter ς = 0.01, and we perform iterations
until the results satisfy convergence criterion (11) with θ = 10.
Software, hardware, accuracy and cost Our programs are written in
Matlab, version 7.6.0.324 (R2008a). We use a desktop computer with a
Quad processor Intel(R) Core(TM) i7 CPU920 @2.67GHz, RAM 6,00GB
and Windows Vista 64 bits. For each model studied, we report the running
time in seconds: for SSA, the running time is defined as the time needed to
compute a linear solution starting from a given initial guess, and for CGA, the
running time is defined as the time needed to compute a quadratic solution
starting from a linear SSA solution. Accuracy tests are performed using the
testing bench of Juillard and Villemot (2010), and the results of these tests
are described in KMMP (2010).
13

Using the iteration-on-allocation routines in simulation plays a key role in the overall
accuracy of SSA and CGA because it allows us to solve for the intratemporal choice with
essentially zero errors; see Table 4.3 in KKMP (2010). This would not be possible if we
constructed and supplied the standard explicit consumption and/or labor policy functions
in terms of state variables.

26

6.2

Exploring alternative implementations

The current JEDC project was launched in 2003, and since then, we have
implemented many versions of the studied methods. We now compare our
baseline implementation of SSA and CGA to alternative implementations
explored, some of which are illustrated with numerical results in Section 7.
Stochastic simulation algorithm At an early stage of the project, Maliar
and Maliar (2004, 2007) implemented a stochastic simulation approach using
the simulation-based parameterized expectation algorithm (PEA) by Den
Haan and Marcet (1990). Under the PEA, policy functions are parameterized by an exponentiated polynomial and are estimated using non-linear
least-squares regression methods. The least-squares problem is typically illconditioned, which leads to numerical problems.14 Moreover, non-linear regression methods require a good initial guess and involve costly computations
of Jacobian and Heissian matrices. Also, such methods cannot be easily vectorized to estimate the policy functions of all countries simultaneously, which
is critical for speed in multi-country settings; see JMM (2010b) for an extensive discussion. In the present paper, we rely on numerically stable stochastic
simulation approaches described in JMM (2009): we use a linear regression
model and employ a least-squares truncated QR factorization method suited
for use with ill-conditioned problems. This approximation method (implemented in Matlab with the backslash operator) delivers the standard OLS
estimator in the absence of ill-conditioning but removes highly collinear principal components in the presence of ill-conditioning.
We submitted for the comparison in KMMP (2010) the first-degree polynomial approximation because under the chosen simulation length T = 10, 000,
it was more accurate than the second-degree polynomial approximation. This
result is explained in JMM (2010b): The accuracy of Monte Carlo integration
employed by SSA depends on how large the simulation length T is relative
to the number of polynomial coeﬃcients in v. The higher is the polynomial degree and/or the dimensionality of the problem, N, the larger is the
number of the coeﬃcients in v, and the larger simulation length is needed
to appropriately identify the coeﬃcients. The simulation length assumed,
14

To be specific, polynomial terms in the approximating polynomial function are highly
correlated (multicollinear), and the regression model cannot be estimated with the standard least-squares method; see Den Haan and Marcet (1990), Christiano and Fisher (2000)
and JMM (2009).

27

T = 10, 000, is suﬃcient to accurately identify the coeﬃcients of the firstbut not the second-degree polynomial. In a model similar to Model 1 of the
current JEDC project, JMM (2010b) find that T should be increased from
10, 000 to 50, 000 and to 100, 000 to make the second-degree polynomial approximation more accurate than the first-degree polynomial approximation
for the model with up to N = 4 and with up to N = 6, respectively. Running
such a long simulation would be costly both in terms of time and memory.
As follows from the comparison in KMMP (2010), even the linear solutions
delivered by SSA are suﬃciently accurate. This is because SSA fits a polynomial exclusively in the relevant area of the state space (the ergodic set)
and also because it solves accurately for the intratemporal choice using the
iteration-on-allocation method.
Cluster-grid algorithm In the case of CGA, we submitted for the comparison in KMMP (2010) the second-degree polynomial approximation. CGA
relies on accurate numerical integration methods, and the second-degree polynomial approximation is considerably more accurate than the first-degree
one. The third-degree polynomial approximation is even more accurate. In
particular, JMM (2010a) find that an increase in the polynomial degree used
in CGA increases accuracy roughly by an order of magnitude in the examples
considered. In Section 7, we compare the accuracy of the CGA method in the
context of the current JEDC project using the first-, second- and third-degree
ordinary polynomials, as well as using alternative Smolyak polynomials.
We also test how sensitive the CGA solutions are to the way in which the
cluster grid is constructed. First, we tried to initialize CGA using a linear
solution delivered by a log-linearization method instead of the one delivered
by SSA.15 Second, we tried to construct clusters using an alternative Kmeans clustering algorithm and/or diﬀerent linkage methods instead of the
baseline hierarchical algorithm with Ward’s linkage. These modifications
do not visibly aﬀect the accuracy and speed of CGA. Finally, concerning
the number of clusters, JMM (2010a) find that oversampling (when there are
more grid points than the polynomial coeﬃcients) increases the accuracy and
numerical stability of the CGA method compared to collocation (when the
number of grid points is the same as the number of polynomial coeﬃcients).
15

In JMM (2010a), CGA is initialized without help of other methods: time series are
simulated for an arbitrary initial guess and used to construct clusters on which a solution
is computed. The obtained solution serves as a more accurate initial guess.

28

In line with this finding, we choose to oversample and use 500 clusters to
identify between 15 to 231 polynomial coeﬃcients in models with N ranging
from 2 to 10, respectively.
To perform numerical integration, we tried to choose the most accurate
integration strategy feasible for problems of given dimensionality, N ≤ 10.
To this purpose, we design a two-step integration procedure that combines
a low-cost monomial rule with 2N nodes (step one) and a costly monomial
(quadrature) rule with 2N nodes (step two). It turned out that, in the studied
models, gains from so accurate integration are minimal relative to less costly
integration alternatives. In Section 7, we investigate how accuracy and cost
of CGA depend on the specific integration method.
Intratemporal-choice approaches In addition to our baseline iterationon-allocation procedure, we explored other approaches for solving for the
intratemporal choice. For all eight models studied, we computed the consumption and/or labor policy functions in terms of state variables within the
main iterative cycle as described in Section 4.1, and we implemented a general
version of the precomputation approach presented in Section 4.3. Also, for
Model 5, we implemented the precomputation approach as described in Example 3, and for Models 6 and 7, we combined the precomputation approach
and a numerical solver as described in Section 4.4.
To generate the results used for comparison in KMMP (2010), we opt for
the most accurate method, which is iteration-on-allocation. However, our
precomputation approach is a useful alternative to consider as it is faster than
the iteration-on-allocation approach. In particular, it was adopted by Pichler
(2010) for his solution method. In Section 7, we compare the performance of
alternative intratemporal-choice approaches in the context of Model 5.

7

Additional numerical results

Accuracy and speed of SSA and CGA under the baseline implementation is
assessed in KMMP (2010). In this section, we provide additional numerical
results for CGA, which show how its accuracy and speed depend on the specific intratemporal-choice approach, approximating polynomial function and
integration method. To assess the accuracy of solutions, we implement a test
that computes the average and maximum solution errors along a stochastic simulation of 10, 000 observations as described in Juillard and Villemot
29

(2010).

7.1

Comparison of intratemporal choice approaches

To illustrate the role of the specific intratemporal-choice approach in determining the accuracy of solutions, we use a two-country version of Model 5.
We allow an intratemporal-choice approach used in the solution procedure
diﬀer from that used in the simulation procedure. We report the results
obtained using the second-degree polynomial approximation; the regularities
under the first-order polynomial approximation are similar.
In the solution procedure, we consider four alternative intratemporalchoice approaches: (i) parameterize the consumption policy functions of
both countries with a polynomial of the state variables and compute the
polynomial coeﬃcients inside the main iterative cycle; (ii) parameterize and
compute only the consumption policy function of country 1 inside the main
iterative cycle and find consumption of country 2 from closed-form expression (12); (iii) precompute the consumption manifold of country 1 outside the
main iterative cycle in terms of aggregate consumption as described in Example 3 and find consumption of country 2 from (12); (iv) solve for consumption
of both countries using the iteration-on-allocation approach, as described in
Example 1.
In the simulation procedure, we solve for the intratemporal choice using
four approaches that are parallel to those used in the solution procedure: (a)
use the computed solution to construct the consumption policy functions for
both countries in terms of the state variables (if not constructed by the solution method used); (b) use the solution to construct the consumption policy
function of country 1 in terms of the state variables (if not constructed by
the solution method used) and find consumption of country 2 from (12); (c)
find consumption of country 1 using the consumption manifold precomputed
by method (iii) and find consumption of country 2 from (12); (d) solve for
consumption of both countries using the iteration-on-allocation approach.
To implement precomputation in (iii), we consider an interval for aggregate consumption equal to ±20% of the steady-state value, and we split this
interval into 300 equally spaced points. Outside the main iterative cycle,
for each value of aggregate consumption cp , we compute c1p numerically from
(16). Inside the main iterative cycle, we compute aggregate consumption ct
from (2) and find the corresponding c1t using a piecewise linear polynomial
interpolation. We tried other interpolation schemes such as a global high30

order polynomial approximations, piecewise cubic polynomial interpolation,
splines, etc., and found that piecewise low-order polynomial interpolation
schemes lead to more accurate solutions (though are more costly) than global
high-order polynomial approximations.
In Table 1, we present the results of combining methods (i)-(iv) in the
solution procedure with methods (a)-(d) in the simulation procedure (all errors that are less than 10−10 are replaced by −∞). As the table indicates,
if in both the solution and simulation procedures, we approximate a policy
function for consumption using a second-degree polynomial of state variables,
the resulting accuracy is low (namely, errors in the intratemporal-choice conditions including the resource constraint are large). If in the solution procedure, we solve for consumption very accurately (using precomputation and
iteration-on-allocation) but in simulation, we solve for consumption not so
accurately (using second-degree polynomials of state variables), the resulting accuracy is again low. Finally, if in the solution procedure, we solve for
consumption not very accurately (using second-degree polynomials of state
variables), but in simulation, we solve for consumption very accurately (using precomputation and iteration-on-allocation), the accuracy gets restored.
These tendencies lead us to conclude that it is not so important for accuracy
how we compute the intratemporal choice in the solution procedure but how
we compute it in simulation (when running accuracy tests).
We would like to highlight two additional findings about accuracy in Table
1. First, accuracy does not depend significantly on whether we approximate
one or more than one intratemporal-choice variable using second-degree polynomials of state variables; in both cases, we suﬀer approximately the same
accuracy loss. Second, the methods solving for the intratemporal choice accurately lead to considerably larger Euler-equation errors than those solving
for the intratemporal choice less accurately.
Finally, Table 1 also shows the time, T CP U, needed to run the test on
a stochastic simulation of 10, 000 observations. Under the precomputation
approach, T CP U is only slightly larger than under the standard approach
constructing the consumption and labor policy functions in terms of state
variables, while under the iteration-on-allocation approach, T CP U is almost
20 times larger. The iteration-on-allocation approach performs slowly in the
test because our testing procedure is not vectorized along the time dimension;
i.e., we use the iteration-on-allocation solver 10, 000 times to compute c1t and
c2t period by period.

31

7.2

Cost of iteration-on-allocation

We now quantify the benefits of vectorizing the iteration-on-allocation approach along the time dimension. In Table 2, we compare the time necessary
to simulate a time-series solution of length T under two alternative simulation procedures: one in which the intratemporal choice is computed using the
standard policy functions represented by second-degree polynomials of state
variables (CP U1) and the other in which the intratemporal choice is computed using the iteration-on-allocation solver (CP U2). As an initial guess
for allocations in the latter procedure, we use the allocations obtained in the
former procedure.
Since our simulation routines are written in a vectorized form, the cost of
iteration-on-allocation depends dramatically on the simulation length. When
we simulate only one period entry (i.e., T = 1), the iteration-on-allocation
approach is about 67 and 362 times more costly for Models 1 and 4, respectively, than the standard approach based on policy functions. However, as T
increases, the relative cost of iteration-on-allocation decreases; in particular,
for T = 10, 000, the iteration-on-allocation approach is about 4% and 250%
more costly for Models 1 and 4, respectively, than the standard approach
based on policy functions. The latter value is an upper bound. In other
cases, the relative cost of iteration-on-allocation is even lower.

7.3

Approximating functions and integration methods

In Table 3, we assess the eﬀect of the specific approximating function and
integration method on the accuracy of CGA in the context of two-country
versions of Models 5-8. For each model studied, we consider four alternative
approximating functions: the first-, second- and third-degree ordinary polynomials, as well as the Smolyak polynomial used in MKK (2010). We also
consider five alternative integration methods: the product Gauss-Hermite
rule with 1, 2N , 3N nodes, denoted Q (1), Q (2) and Q (3), respectively; and
the monomial formulas with 2N and 2N 2 + 1 nodes, denoted M1 and M2,
respectively.
We observe the following regularities from the table. First, all of the integration rules considered, except for the one-node Gauss-Hermite rule Q (1),
deliver solutions of virtually the same accuracy, with errors that are identical
to the fourth digit. The Q (1) rule produces errors that are slightly larger;
however, this rule has a substantially lower cost than the other integration
32

methods and thus allows to solve problems of much higher dimensionality.
In particular, JMM (2010a) use the Q (1) rule to compute first- and seconddegree polynomial solutions to a model (similar to Model 1 of the current
project) with up to N = 200 and N = 40 countries, respectively.
Second, when solutions are computed using ordinary polynomials, increasing the polynomial degree from one to two raises accuracy (reduces
errors) by more than an order of magnitude; increasing the polynomial degree from two to three does so by slightly less than an order of magnitude.
However, it is costly to increase the degree of a complete polynomial in highdimensional problems. As is seen from Table 3, the Smolyak polynomial is a
useful alternative for CGA: It leads to as nearly as accurate solutions as the
third-degree complete polynomial, but its number of terms grows quadratically instead of cubically with dimension (the Smolyak polynomial has only
four times more terms than the second-degree complete polynomial independently of dimension); see MKK (2010) for a discussion and definition of the
Smolyak polynomial.
In Table 4, we investigate how the cost and accuracy of CGA depend
on the specific integration method used. To this purpose, we recompute the
solutions to Models 5-8 under four alternative integration methods: Q(1),
Q(2), M1 and M2. The accuracy measures in our Table 4 are analogous
to those reported in Table 5 of KMMP (2010); however, our testing procedure uses random draws, which are diﬀerent from those used by Juillard and
Villemot (2010). As Table 4 shows, the errors we found are very close to
those shown in Table 5 of KMMP (2010). Furthermore, all of the integration methods considered again lead to solutions of nearly the same accuracy,
with the exception of the Q(1) rule (which produces slightly less accurate
solutions).
The key finding in our Table 4 is that CGA can compute solutions of the
same accuracy as those submitted for the comparison in KMMP (2010), but
at a much lower cost. For example, we reduce the computational time for
Model 5 with N = 10 countries from about 35 hours (reported in Table 3 of
KMMP, 2010) to 7 minutes (reported in our Table 4) without a visible loss
in accuracy by replacing our costly, baseline two-step integration procedure
with just its first step based on the M1 monomial rule with 2N nodes.16 Al16
At the moment of submission of our solutions for the comparison in KMMP (2010), we
did not have a reliable accuracy test, and we submitted the solutions obtained under the
most accurate integration procedure feasible for CGA, which is a two-step combination of
the M 1 and Q(2) rules.

33

ternatively, we can solve a ten-country version of Model 5 in about 2 minutes
using the Q(1) rule at the cost of a modest loss in accuracy. In Models 6-8, the
cheaper integration rules reduce the computational time in roughly the same
proportion as in Model 5. However, Models 6-8 are generally more costly
to solve than Model 5 because of higher costs of computing the intratemporal choice. The computational time for these models can be reduced (at
the cost of some accuracy loss) by combining the iteration-on-allocation and
precomputation approaches, as described in Section 4.3. In addition, we can
decrease the computational time for all models by reducing the number of
clusters; see JMM (2010a) for the corresponding experiments.

7.4

Hybrid of perturbation and accurate intratemporalchoice methods

In Section 7.1, we show that using accurate intratemporal-choice approaches
in simulation can increase the accuracy of solution methods that compute the
intratemporal choice with insuﬃcient accuracy. A prominent example of such
a method is perturbation, which in the studied models, produces small errors
in the Euler equations but large errors in the intratemporal-choice conditions
(especially, in the resource constraint); see Table 6 of KMMP (2010) for the
accuracy by equation for the first- and second-order perturbation methods
by Kollmann, Kim and Kim (2010) (referred to as PER1 and PER2, respectively). Consequently, there are potential benefits from constructing a hybrid
of the standard perturbation method (used as a low-cost method for computing capital policy functions), and accurate intratemporal-choice methods
(used to solve for consumption and labor after capital is computed).
To verify the above conjecture, we take the capital policy functions produced by the standard log-linearization method for two-country versions of
Models 5-8 and accurately solve for consumption and labor in simulation using the iteration-on-allocation method. In Table 5, we compare the accuracy
of the resulting hybrid method with that of the SSA, CGA, PER1 and PER2
methods, as reported in Table 5 of KMMP (2010).
As Table 5 indicates, our hybrid method is far more accurate (by more
than an order of magnitude) than PER1. It is even more accurate than
PER2 and is only slightly less accurate than SSA. The hybrid method is still
considerably less accurate than CGA. However, when comparing the hybrid
method against CGA, we should take into account that the latter uses the

34

second-degree polynomial, while the former uses the first-degree polynomial.
The second-order hybrid perturbation method is likely to be more accurate
than the first-order one.
Finally, to construct the hybrid perturbation method, we can use any
numerical procedure that can accurately solve the system of intratemporalchoice conditions with respect to consumption and labor; e.g., a standard
Newton-type solver. However, as we argued before, the iteration-on-allocation
solver has advantages over other solvers. It is a good candidate for a fusion
with perturbation.

8

Conclusion

In this paper, we oﬀer a mix of techniques that taken together allows us to
address the challenges of high-dimensional problems. First, SSA and CGA
operate on ergodic-set domains which in high-dimensional problems, are normally just a tiny fraction of the standard hypercube domain used by other
methods. Second, we use eﬃcient and numerically stable linear approximation approaches described in JMM (2009). Third, we rely on low-cost
integration methods, namely, a Monte Carlo integration method combined
with regression under SSA, and non-product monomial rules and the GaussHermite rule with one node under CGA. Fourth, we solve for the intratemporal choice using the accurate iteration-on-allocation and precomputation
methods. Fifth, we show that other polynomial families (such as Smolyak
polynomials studied in MKK, 2010) can help increase accuracy and speed of
our solution methods relative to our baseline family of ordinary polynomials.
Finally, we argue that proper coordination of the approximation, integration and intratemporal-choice strategies is critical for accuracy, speed and
numerical stability of our solution methods.
If one uses a standard desktop computer (as we do), it is crucial for speed
to vectorize computations. We iterate on policy functions of all countries simultaneously rather than country by country, and we solve for the intratemporal choice in all points at once rather than point by point. In contrast,
if one uses parallel computing tools, it is essential to separate computations
by country, grid point, integration node, etc. We should emphasize that the
methods described in the paper are naturally parallelizable.
In addition to our main SSA and CGA algorithms, we construct a hybrid solution algorithm that combines perturbation (used to compute policy
35

functions for capital) and accurate intratemporal-choice methods (used to
solve for consumption and labor allocations). We find that such a hybrid
method delivers solutions that are more than an order of magnitude more
accurate than those delivered by the pure perturbation method. This hybrid perturbation method can be useful for solving problems of much higher
dimensionality than those studied in the present paper.

References
[1] Christiano, L. and D. Fisher, (2000). Algorithms for solving dynamic
models with occasionally binding constraints. Journal of Economic Dynamics and Control 24, 1179-1232.
[2] Den Haan, W. (1990). The optimal inflation path in a Sidrauski-type
model with uncertainty. Journal of Monetary Economics 25, 389-409.
[3] Den Haan W., K. Judd and M. Juillard, (2010). Computational suite
of models with heterogeneous agents: Milti-country real business cycle models. Journal of Economic Dynamics and Control (special issue),
forthcoming.
[4] Den Haan, W. and A. Marcet, (1990). Solving the stochastic growth
model by parameterizing expectations. Journal of Business and Economic Statistics 8, 31-34.
[5] Den Haan, W. and A. Marcet, (1994). Accuracy in simulations. Review
of Economic Studies 6, 3-17.
[6] Gaspar, J. and K. Judd, (1997). Solving large-scale rational-expectations
models. Macroeconomic Dynamics 1, 45-75.
[7] Judd, K., (1992). Projection methods for solving aggregate growth models. Journal of Economic Theory 58, 410-452.
[8] Judd, K., (1998). Numerical Methods in Economics. London, England:
The MIT Press, Cambridge Massachusetts.
[9] Judd, K., L. Maliar and S. Maliar, (2009). Numerically stable stochastic simulation approaches for solving dynamic economic models, NBER
working paper 15296.
36

[10] Judd, K., L. Maliar and S. Maliar, (2010a). A cluster-grid projection
method: solving problems with high dimensionality, NBER working paper 15965.
[11] Judd, K., L. Maliar and S. Maliar, (2010b). Numerically stable stochastic simulation approaches for solving dynamic economic models. Manuscript.
[12] Juillard, M. and S. Villemot, (2010). Multi-country real business cycle
models: accuracy tests and testing bench. Journal of Economic Dynamics and Control (special issue), forthcoming.
[13] Kollmann, R., S. Kim and J. Kim, (2010). Solving the multi-country real
business cycle model using a perturbation method. Journal of Economic
Dynamics and Control (special issue), forthcoming.
[14] Maliar, L. and S. Maliar, (2001). Heterogeneity in capital and skills in
a neoclassical stochastic growth model. Journal of Economic Dynamics
and Control 25, 1367-1397.
[15] Maliar, L. and S. Maliar, (2003a). The representative consumer in the
neoclassical growth model with idiosyncratic shocks. Review of Economic Dynamics 6, 362-380.
[16] Maliar, L. and S. Maliar, (2003b). Parameterized expectations algorithm
and the moving bounds. Journal of Business and Economic Statistics 21,
88-92.
[17] Maliar, L. and S. Maliar, (2004). Comparing numerical solutions of models with heterogeneous agents (Model A): a
simulation-based parameterized expectations algorithm. Manuscript.
http://www.stanford.edu/~maliars/
[18] Maliar, L. and S. Maliar, (2005). Parameterized expectations algorithm:
how to solve for labor easily. Computational Economics 25, 269-274.
[19] Maliar, L. and S. Maliar, (2007). Comparing numerical solutions of models with heterogeneous agents (Model A): a
simulation-based parameterized expectations algorithm. Manuscript.
http://www.stanford.edu/~maliars/

37

[20] Malin, B., D. Krueger, and F. Kubler, (2010). Solving the multi-country
real business cycle model using a Smolyak-collocation method. Journal
of Economic Dynamics and Control (special issue), forthcoming.
[21] Marcet, A., (1988). Solution of nonlinear models by parameterizing expectations. Carnegie Mellon University. Manuscript.
[22] Pichler, P., (2010). Solving the multi-country real business cycle model
using a monomial rule Galerkin method. Journal of Economic Dynamics
and Control (special issue), forthcoming.
[23] Stroud A., (1971). Approximate Integration of Multiple Integrals. Prentice Hall: Englewood Cliﬀs, New Jersey.
[24] Taylor, J. and H. Uhlig, (1990). Solving nonlinear stochastic growth
models: a comparison of alternative solution methods. Journal of Business and Economic Statistics 8, 1-17.

9

Appendix

In this section, we present formulas used to implement the iteration-onallocation and precomputation methods, as well as those used to parameterize the capital policy functions.

9.1

Appendix A

This section describes how we implement the iteration-on-allocation approach
in Models 6-8 (and their corresponding symmetric counterparts, Models 2-4).
Model 6 Conditions (4), (5) and (2) can be represented as
# ηj
j
1
j ¡ j ¢α 1 1 1+αηj
)
¡ 1 ¢ ηη1(1+αη
τ
b
k
a
t
t
j
(1+αηj )
et =
α
t
a1t (kt1 ) τ j bj
"

e
cjt

¡ ¢α ¡ j ¢−α #γ j
lt
(1 − α) ajt A ktj
=
,
¡ j ¢1/ηj
bj lt
"

with

38

½

j = 2, ..., N,

(28)

ltj ≡ 1t , j = 1
, (29)
ltj ≡ ejt , j = 2, ..., N

⎡

⎢
⎢
e1 = ⎢
t
⎢
⎣

PN

j=1

"

j
e
cjt + kt+1
− ktj + φ2 ktj

⎤ 1
¶2 #
PN j ¡ j ¢α ³ ej ´1−α 1−α
− j=2 at A kt
−1
⎥
t
ktj
⎥
⎥
,
1
1 α
⎥
at A (kt )
⎦

µ

j
kt+1

(30)
where {γ , η , b }
are the utility-function parameters, and α is the
share of capital in production. Condition (28) is obtained by combining (4)
and (5), and conditions (29) and (30) follow from (5) and (2), respectively.
For given kt , at , kt+1 , equations (28) −(30) define a mapping e1t = g ( 1t ). We
iterate on labor of the first country, e1t , as follows: Assume some initial 1t ;
n oj=2,...,N
© j ªj=1,...,N
from (28); find e
ct
from (29); obtain e1 from
compute ejt
j

j

j j=1,...,N

t

(30); if 6= e1t , compute the next-iteration input as (1 − ξ)
until convergence.
1
t

Model 7 Conditions (5) and (4), respectively, are
¢
¡
¡ ¢α ¡ j ¢−α
ψ Le − jt
j
(1 − α) ajt A ktj
e
ct =
,
t
1−ψ
"
¡
j
et = Le − Le −

1
1 ψ(1−1/γ )−1 1
1 (e
¢
)
τ
c
(1−ψ)
1−1/γ
(
)
t
1
t
¡ j ¢ψ(1−1/γ j )−1
τj
e
ct

1
t

1
# (1−ψ)(1−1/γ
j)

+ ξ e1t . Iterate

(31)

, j = 2, ..., N,

(32)
where ψ is the utility-function parameter, and L is the labor endowment
of the representative agent. The resource constraint is given by (30) and
determines e1t . For given kt , at , kt+1 , equations (30), (31) and (32) define a
³© ªj=1,...,N ´
n oj=1,...,N
j
j
e
. We iterate on labor of all countries,
=g
mapping t
t
n oj=1,...,N
© ªj=1,...,N
© j ªj=1,...,N
ejt
, as follows: Assume some initial jt
, find e
ct
n oj=2,...,N
from (31); compute ejt
and e1t from (32) and (30), respectively; if
j
j
ej
ej
t 6= t for j = 1, ..., N, calculate the next-iteration input as (1 − ξ) t + ξ t .
Iterate until convergence.

39

e

Model 8 Conditions (5), (4) and (2), respectively, are
⎡

⎢ (1 −
e
cjt = ⎢
⎣
ejt

α) ajt A

⎡

⎢1
=L −⎣ j
b
e

Ã

⎤χj
¡ j ¢μj −1 ³ ¡ j ¢μj
¡ j ¢μj ´1/μj −1
α kt
+ (1 − α) t
⎥ ¡ e
¢
t
⎥ L − jt ,
⎦
bj

u1c,t τ 1
¡ j ¢−1/χj
e
ct
τj

⎡Ã
e1 = ⎣
t

!

⎤

1−1/χj
1/χj −1/γ j

¡ j ¢1−1/χj
e
ct
⎥
−
⎦
j
b

ft1
1

a1t A (1 − α)1/μ

j=1,...,N

!μj

(33)

1
1−1/χj

μ1

,
⎤ 11

α (kt1 ) ⎦
−
1−α

j = 2, ..., N,
(34)

μ

,

(35)

where {χj , μj }
are the utility-function parameters; ujc,t for j = 1 and
ft1 are, respectively, the t-period marginal utility of consumption and output
of country 1, defined as
ujc,t

1/χj −1/γ j
h¡ ¢1−1/χj
ji
¡
¢
¡ j ¢−1/χj
1−1/χ
1−1/χj
j
j
≡ ct
+ bj Le − t
,
ct

ft1 ≡

N
X

⎡

φ
j
⎣e
cjt + kt+1
− ktj + ktj
2
j=1

−

N
X
j=2

Ã

j
kt+1
ktj

!2 ⎤
−1 ⎦

(36)

(37)

³ ¡ ¢μj
¡ ¢μj ´1/μj
ajt+1 A α ktj
+ (1 − α) jt
.

n oj=1,...,N
For given kt , at , kt+1 , equations (33) − (35) define a mapping ejt
=
n oj=1,...,N
³© ªj=1,...,N ´
j
. We iterate on labor of all countries, ejt
, as folg
t
© j ªj=1,...,N
© j ªj=1,...,N
; find e
ct
from (33); compute
lows: Assume some initial t
n oj=2,...,N
ejt
and e1 using (34) and (35), respectively; if jt 6= ejt for j = 1, ..., N,
t

calculate the next-iteration input as (1 − ξ) jt +ξ ejt . Iterate until convergence.
40

9.2

Appendix B

In this section, we show that in Model 2, the solution manifold for aggregate consumption can be precomputed in terms of two composite arguments
independently of the number of agents. Since all agents are identical in preferences and have identical welfare weights, τ j = 1 for j = 1, ..., N, the ratio
of marginal utilities of any two agents in (4) is equal across agents. As a
result, cjt = ct /N for all j. From the intratemporal FOC (5), we obtain
η
#− 1+αη
"
1/γ −1/γ
N
b
c
j
t
.
(38)
¡ ¢α
t =
(1 − α) Aajt ktj
Substituting (38) into resource constraint (2), we obtain
ct =

η(1−α)
− γ(1+αη)
ct
qt

(39)

+ dt ,

with the composite variables qt and dt being defined as
PN h j ¡ j ¢α i1+ η(1−α)
Ã
!2
1+αη
j
j=1 Aat kt
φ j kt+1
j
,
dt = − kt
+ ktj − kt+1
.
qt =
j −1
h
i η(1−α)
2
k
1+αη
N −1/γ b
(1−α)

t

(40)
We can use equation (39) to precompute consumption ct in terms of two
variables qt and dt . (If welfare weights diﬀer across agents and consequently,
individual consumption is not equal to average consumption, we can still
construct the intratemporal-choice manifolds in terms of the same composite
variables; see Maliar and Maliar, 2001, 2003b, for related results).
Outside the main iterative cycle, take a grid of P values for qt and dt ,
i.e., {qp , dp }p=1,...,P . For each grid point p = 1, ..., P , use a numerical solver
to find a solution for cp from equation (39) represented in a form suited
for precomputation. Interpolate the constructed set function to the relevant
continuous domain to obtain the manifold b
c (q, d). Inside the main iterative
cycle, given kt , at , kt+1 , compute qt and dt from (40) for each t, use the
precomputed manifold to find aggregate consumption, ct = b
ct (qt , dt ), and
j
compute individual labor t from (38) for j = 1, ..., N.

9.3

Appendix C

In this section, we provide Euler equation (19) corresponding to Models 5-8.
41

Model 5
j
kt+1

Model 6
j
kt+1

⎧ ¡
⎫
⎨ cj ¢−1/γ j h
i
¡ j ¢α−1 j ⎬
j
j
θ
kt+1 .
= Et β ¡ t+1
+
αa
A
kt+1
t+1
⎩ cj ¢−1/γ j ωj t+1
⎭
t
t

⎧ ¡
⎨ cj ¢−1/γ j h
¡ j ¢α−1 ¡
j
j
θ
= Et β ¡ t+1
+
αa
A
kt+1
j
t+1
⎩ cj ¢−1/γ ω j t+1
t

t

j
t+1

¢1−α i

j
kt+1

Model 7

j
kt+1

⎧ k
j
l
ψ
1−ψ 1−1/γ
⎪
cjt+1 ) (Le − jt+1 )
(
⎪
⎪
⎨
h
¡ j ¢α−1 ¡
cjt+1
θjt+1 + αajt+1 A kt+1
= Et β k
j
l
1−1/γ
ψ
1−ψ
⎪
⎪
cj
Le − jt )
⎪
⎩ ( t) (
ωj
cjt

t

⎫
⎬
⎭

(41)

. (42)

j ¢1−α
t+1

i

j
kt+1

(43)

⎫
⎪
⎪
⎪
⎬
⎪
⎪
⎪
⎭

.

Model 8
j
kt+1
= Et

where

ujc,t

(

β

ujc,t+1
ujc,t ω jt

∙
¡ j ¢μj −1 ³ ¡ j ¢μj
¡
α kt+1
θjt+1 + αajt+1 A kt+1
+α

is defined as in (36).

42

j
t+1

¢μj ´1/μj −1
(44)

¸

j
kt+1

)

,

Figure 2a. Iteration-on-allocation under -1<g'<0:
convergence without damping.

Figure 2b. Iteration-on-allocation under g'<-1:
divergence without damping.

1

1

0.8

0.8

c1t
g(c1)

0.6

g(c1t )

g(c1t )

0.4

0.2

0.2

0

c1t

0.6

t

0.4

0

1

g(ct )

0.2

0.4

0.6

0.8

0

1

0

0.2

0.4

0.6

0.8

c1
t

c1
t

Figure 2c. Iteration-on-allocation under -1<g'<0:
convergence with damping.

Figure 2d. Iteration-on-allocation under g'<-1:
convergence with damping.

1

1

1

0.8

0.8
c1t

g(c1)
t

t

g(c1t )

0.6

g(c1t )

0.6

c1

g(c1t )

0.4

0.4

0.2

0.2

0

0

0.2

0.4

0.6

0.8

1

c1
t

0

0

0.2

0.4

0.6
c1
t

0.8

1

Note: Figures 2a-2d illustrate possible outcomes of the iteration-on-allocation method; c1t is consumption of the first country; g is the mapping
used in the iteration-on-allocation method and g' is the first derivative of g.

Table 1. Accuracy and time needed to run the test for the two-country version of Model 5 under alternative intratemporal-choice
approaches.
Intratemporal choice in the simulation procedure

Intratemporal
choice in
the solution
procedure

Equation

(i)

Euler

-6.14 -4.55

Two policy

RC

-4.93 -3.48

functions

Intrat

-4.64 -3.22

(ii)

Euler

-5.98 -4.57

One policy

RC

-4.68 -3.60

function

Intrat

-4.69 -3.17

(iii)

Euler

-5.98 -4.42

Precomputation

RC

-4.66 -3.63

Intrat

-4.65 -3.28

(iv)

Euler

-5.99 -4.42

Iteration-on-

RC

-4.66 -3.63

allocation

Intrat

-4.65 -3.28

(a) Two policy
functions
∆mean

∆max

TCPU
15

(b) One policy
function
∆mean

∆max

-6.02 -4.55

TCPU
15

-4.54 -3.09
-∞
15

14

15

15

14

-4.42 -3.18
-∞

-∞

17

-∞

-5.69 -4.35

16

-5.89 -5.61

-∞

-5.92 -4.42

17

-∞

-5.68 -4.29

-∞

-4.43 -3.17
-∞

TCPU

-5.89 -5.61

-∞

-5.91 -4.42

∆max

-5.68 -4.29

-∞

-4.54 -3.09
-∞

∆mean

-5.89 -5.61

-∞

-6.06 -4.57

(c) Precomputation

-∞
15

-∞

-5.69 -4.35
-5.89 -5.61
-∞

-∞

17

(d) Iteration-on-allocation
∆mean

∆max

-5.73 -4.29
-∞

-∞

-∞

-∞

-5.72 -4.28
-∞

-∞

-∞

-∞

-5.74 -4.35
-∞

-∞

-∞

-∞

-5.74 -4.35
-∞

-∞

-∞

-∞

TCPU
226

226

231

232

Note: ∆mean and ∆max are, respectively, the average and maximum errors in the corresponding optimality condition (in log10
units) in the test on a stochastic simulation of 10,000 observations; TCPU is the time needed to run the test (in seconds).
Abbreviations “Euler”, “RC” and “Intrat” denote the Euler equations, resource constraint and intratemporal-choice conditions,
respectively.

Table 2. Time for simulating Models 5-8 under two alternative simulation procedures: one using policy functions and the other using
iteration-on-allocation.

N
Model 5
2
4
6
8
10
Model 6
2
4
6
8
Model 7
2
4
6
Model 8
2
4
6

T=1
CPU1

T=10
CPU2

CPU1

CPU2

T=100
CPU1
CPU2

T=1,000
CPU1
CPU2

T=10,000
CPU1
CPU2

0.0001
0.0001
0.0001
0.0001
0.0001

0.0071
0.0041
0.0033
0.0028
0.0022

0.0004
0.0004
0.0004
0.0005
0.0006

0.0090
0.0055
0.0046
0.0040
0.0036

0.0030
0.0037
0.0045
0.0055
0.0072

0.0182
0.0144
0.0171
0.0173
0.0184

0.0415
0.0645
0.2483
0.5870
0.9490

0.1038
0.1218
0.3546
0.6553
1.0325

5.4893
22.1597
48.7948
82.8177
124.5969

5.7720
22.4737
49.0005
83.3027
124.5281

0.0001
0.0001
0.0002
0.0002

0.0035
0.0019
0.0011
0.0015

0.0004
0.0006
0.0006
0.0007

0.0056
0.0038
0.0027
0.0033

0.0032
0.0041
0.0052
0.0067

0.0219
0.0204
0.0167
0.0205

0.0416
0.0694
0.2573
0.5774

0.1754
0.1941
0.3730
0.7385

5.4723
22.4622
49.1699
83.1369

6.0610
22.9424
49.5512
83.7333

0.0001
0.0001
0.0001

0.0302
0.0200
0.0227

0.0003
0.0004
0.0004

0.0430
0.0422
0.0506

0.0033
0.0038
0.0048

0.1544
0.2006
0.2958

0.0410
0.0645
0.2525

1.0800
1.3623
2.0232

5.5069
22.4296
49.0937

9.8106
28.5446
58.5057

0.0001
0.0001
0.0002

0.0381
0.0555
0.0694

0.0004
0.0004
0.0006

0.0622
0.1076
0.1595

0.0033
0.0041
0.0050

0.2730
0.6396
0.9718

0.0412
0.0664
0.2472

2.1903
5.1589
8.5013

5.5690
22.4694
49.2921

14.0949
53.7229
101.2122

Note: CPU1 and CPU2 are, respectively, the time necessary to simulate a time-series solution of length T under the simulation
procedure using policy functions and the one using iteration-on-allocation (in seconds); N is the number of countries.

Table 3. Effect of the specific polynomial on accuracy of CGA under five integration rules in the two-country versions of Models 5-8.
Polynomial
Model 5
1st
2nd
3rd
SMOL
Model 6
1st
2nd
3rd
SMOL
Model 7
1st
2nd
3rd
SMOL
Model 8
1st
2nd
3rd
SMOL

Q(3)

Q(2)

M2

M1

Q(1)

∆mean

∆max

∆mean

∆max

∆mean

∆max

∆mean

∆max

∆mean

∆max

-4.90195
-6.38976
-7.15921
-7.06458

-3.13194
-4.34742
-5.15528
-5.05292

-4.90194
-6.38976
-7.15696
-7.06445

-3.13194
-4.34735
-5.15517
-5.05265

-4.90193
-6.38974
-7.15966
-7.06427

-3.13194
-4.34730
-5.15600
-5.05233

-4.90193
-6.38974
-7.15709
-7.06425

-3.13194
-4.34730
-5.15556
-5.05236

-4.88823
-5.86835
-5.89480
-5.89095

-3.13396
-4.30024
-4.96021
-4.83609

-4.82343
-6.27646
-7.15049
-6.98459

-3.02274
-4.30442
-5.15572
-4.98077

-4.82342
-6.27647
-7.15109
-6.98441

-3.02274
-4.30437
-5.15531
-4.98053

-4.82340
-6.27646
-7.15136
-6.98414

-3.02274
-4.30432
-5.15497
-4.98026

-4.82341
-6.27647
-7.15144
-6.98409

-3.02274
-4.30432
-5.15489
-4.98026

-4.75012
-5.70532
-5.72017
-5.71619

-3.03238
-4.23380
-4.78838
-4.70282

-4.77765
-6.07533
-7.06964
-6.78548

-3.03091
-4.24781
-4.99023
-4.72708

-4.77765
-6.07537
-7.07030
-6.78540

-3.03091
-4.24774
-4.99064
-4.72691

-4.77763
-6.07538
-7.07040
-6.78532

-3.03091
-4.24771
-4.99073
-4.72679

-4.77764
-6.07539
-7.07057
-6.78525

-3.03091
-4.24770
-4.99098
-4.72677

-4.73123
-5.65946
-5.67346
-5.66775

-3.03668
-4.20806
-4.75051
-4.54921

-4.58750
-5.87377
-6.81686
-6.69808

-2.80045
-3.83040
-4.38437
-4.56910

-4.58750
-5.87378
-6.81684
-6.69794

-2.80045
-3.83037
-4.38446
-4.56898

-4.58749
-5.87377
-6.81679
-6.69782

-2.80045
-3.83035
-4.38448
-4.56889

-4.58749
-5.87378
-6.81674
-6.69777

-2.80045
-3.83035
-4.38452
-4.56889

-4.53314
-5.52168
-5.57508
-5.57173

-2.80015
-3.79411
-4.27229
-4.40082

Note: ∆mean and ∆max are, respectively, the average and maximum absolute errors across all optimality conditions (in log10 units) in the
test on a stochastic simulation of 10,000 observations. Abbreviations “1st”, “2nd”, “3rd” and “SMOL” denote the first-, second-, thirddegree ordinary polynomials and the Smolyak polynomial, respectively.

Table 4. Accuracy and speed of CGA for Models 5-8 under four integration rules.
N
Model 5
2
4
6
8
10
Model 6
2
4
6
8
Model 7
2
4
6
Model 8
2
4
6

∆mean

Q(2)
∆max

CPU

∆mean

M2
∆max

CPU

∆mean

M1
∆max

CPU

∆mean

Q(1)
∆max

CPU

-6.39
-6.44
-6.44
-6.42
-6.39

-4.35
72
-4.45
145
-4.66
575
-4.76
4319
-4.74 144327

-6.39
-6.44
-6.44
-6.42
-6.38

-4.35
-4.45
-4.66
-4.76
-4.75

91
227
661
1822
4425

-6.39
-6.44
-6.44
-6.42
-6.38

-4.35
-4.45
-4.66
-4.76
-4.75

73
105
161
290
420

-5.87
-5.70
-5.64
-5.62
-5.62

-4.30
-4.36
-4.50
-4.57
-4.56

63
76
94
115
137

-6.28
-6.31
-6.32
-6.31

-4.30
-4.45
-4.62
-4.66

1231
2687
8556
38392

-6.28
-6.31
-6.32
-6.31

-4.30
-4.45
-4.62
-4.66

1417
3804
8128
19635

-6.28
-6.31
-6.32
-6.31

-4.30
-4.45
-4.62
-4.66

1234
1781
2207
3864

-5.71
-5.52
-5.46
-5.44

-4.23
-4.35
-4.40
-4.46

963
1104
1052
1444

-6.08
-6.09
-6.09

-4.25
-4.21
-4.33

759
1842
6254

-6.08
-6.09
-6.09

-4.25
-4.21
-4.33

912
2745
7723

-6.08
-6.09
-6.09

-4.25
-4.21
-4.33

768
1402
2449

-5.66
-5.52
-5.46

-4.21
-4.16
-4.23

614
887
1173

-5.87
-5.93
-5.96

-3.83
-4.13
-4.22

1185
3807
13414

-5.87
-5.93
-5.96

-3.83
-4.13
-4.22

1400
5631
14385

-5.87
-5.93
-5.96

-3.83
-4.13
-4.22

1177
2913
3869

-5.52
-5.38
-5.32

-3.79
-4.05
-4.09

894
1790
1756

Note: ∆mean and ∆max are, respectively, the average and maximum absolute errors across all optimality conditions (in log10 units) in the
test on a stochastic simulation of 10,000 observations; CPU is the time necessary to compute a solution (in seconds); N is the number of
countries.

Table 5. Accuracy of the hybrid perturbation method and other solution methods for the two-country versions of Models 5-8.
Model
5
6
7
8

SSA
∆mean
-4.79
-4.79
-4.08
-4.62

CGA
∆max
-3.20
-3.12
-3.08
-2.90

∆mean
-6.39
-6.38
-6.15
-5.98

PER1
∆max
-4.53
-4.50
-4.19
-4.07

∆mean
-3.69
-3.53
-3.05
-3.11

PER2
∆max
-1.70
-1.45
-1.20
-1.25

∆mean
-5.13
-4.84
-4.21
-4.35

Hybrid
∆max
-2.60
-2.30
-1.90
-2.09

∆mean
-4.50
-4.56
-4.57
-4.36

∆max
-2.88
-2.84
-2.87
-2.64

Note: ∆mean and ∆max are, respectively, the average and maximum absolute errors across all optimality conditions (in log10 units) in
the test on a stochastic simulation of 10,000 observations: The results for SSA, CGA, PER1 and PER2 are reproduced from KMMP
(2010).

